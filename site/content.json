{"meta":{"title":"yibuyisheng","subtitle":"偶尔玩玩 Java 的前端工程师","description":"yibuyisheng 在 Github 上的个人博客","author":"yibuyisheng","url":"http://yibuyisheng.github.io/blogs/site/index.html"},"pages":[{"title":"","date":"2016-06-09T03:45:40.000Z","updated":"2016-06-09T03:45:40.000Z","comments":true,"path":"demos/-webkit-border-image.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/-webkit-border-image.html","excerpt":"","text":".-webkit-border-image-demo { display: inline-block; width: 400px; height: 200px; border-width: 60px 70px; -webkit-border-image: url(/images/8.jpg) 60 70 round stretch; background-color: red; }"},{"title":"","date":"2016-06-09T03:43:03.000Z","updated":"2016-06-09T03:43:03.000Z","comments":true,"path":"demos/border-image.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/border-image.html","excerpt":"","text":".border-image-demo { display: inline-block; width: 400px; height: 200px; border-width: 60px 70px; border-image: url(/images/8.jpg) 60 70 round stretch; }"},{"title":"","date":"2016-06-09T03:39:07.000Z","updated":"2016-06-09T03:39:07.000Z","comments":true,"path":"demos/border-radius.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/border-radius.html","excerpt":"","text":".demo1 { width: 100px; height: 100px; background: lightblue; border-radius: 20px/5px; }"},{"title":"","date":"2016-06-09T03:49:28.000Z","updated":"2016-06-09T03:49:28.000Z","comments":true,"path":"demos/css background.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/css background.html","excerpt":"","text":".css-background-demo1 { width: 300px; height: 200px; margin: 10px 0; background-image: repeating-linear-gradient(45deg, rgba(255,0,0,.3) 0, rgba(255,0,0,.3) 10px, rgba(0,255,0,.3) 10px, rgba(0,255,0,.3) 20px, rgba(0,0,255,.3) 20px, rgba(0,0,255,.3) 30px, rgba(100,100,0,.3) 30px, rgba(100,100,0,.3) 40px ), repeating-linear-gradient(145deg, rgba(255,0,0,.3) 0, rgba(255,0,0,.3) 10px, rgba(0,255,0,.3) 10px, rgba(0,255,0,.3) 20px, rgba(0,0,255,.3) 20px, rgba(0,0,255,.3) 30px, rgba(100,100,0,.3) 30px, rgba(100,100,0,.3) 40px ); } .css-background-demo2 { width: 300px; height: 200px; background-image: radial-gradient( transparent 50%, rgba(0,255,0,.5) 50%, rgba(0,255,0,.5) 60%, transparent 60%), radial-gradient( transparent 50%, rgba(255,0,0,.5) 50%, rgba(255,0,0,.5) 60%, transparent 60%), radial-gradient( transparent 80%, rgba(0,0,255,.5) 80%, rgba(0,0,255,.5) 90%, transparent 90%); background-size: 40px 40px; background-position: 0 0, 20px 20px, 20px 40px; }"},{"title":"","date":"2016-06-09T03:10:57.000Z","updated":"2016-06-09T03:10:57.000Z","comments":true,"path":"demos/css skew.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/css skew.html","excerpt":"","text":".demo3 { width: 400px; height: 300px; position: relative; } .demo3 .box1, .demo3 .box2, .demo3 .box3, .demo3 .box4 { top: 100px; left: 50px; position: absolute; width: 100px; height: 100px; } .demo3 .box1 { border: 1px #000 dotted; } .demo3 .box2 { border: 1px solid #000; transform: skewX(45deg); -webkit-transform: skewX(45deg); } .demo3 .box3, .demo3 .box4 { left: 240px; } .demo3 .box3 { border: 1px dotted #000; } .demo3 .box4 { border: 1px solid #000; transform: skewY(45deg); -webkit-transform: skewY(45deg); } .demo3 h5 { position: absolute; margin: 0; top: 20px; } .demo3 h5:first-child { left: 24px; } .demo3 h5:nth-child(4) { left: 246px; } skewX(45deg) skewY(45deg)"},{"title":"","date":"2016-06-09T03:47:46.000Z","updated":"2016-06-09T03:47:46.000Z","comments":true,"path":"demos/envelope.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/envelope.html","excerpt":"","text":".demo-envelope { width: 200px; height: 80px; margin: 50px 10px; padding: 1em; border: .5em solid transparent; background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, red 0, red 12.5%, transparent 0, transparent 25%, #58a 0, #58a 37.5%, transparent 0, transparent 50%) 0 / 2em 2em; transform: rotateZ(-10deg); -webkit-transform: rotateZ(-10deg); } the envelope border"},{"title":"","date":"2016-06-09T03:40:29.000Z","updated":"2016-06-09T03:40:29.000Z","comments":true,"path":"demos/half ellipse.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/half ellipse.html","excerpt":"","text":".half-ellipse-demo1 { width: 100px; height: 50px; background: orange; border-radius: 100px 100px 0 0; } .half-ellipse-demo2 { width: 50px; height: 50px; background: orange; border-radius: 100px 0 0 0; }"},{"title":"","date":"2016-06-09T03:50:18.000Z","updated":"2016-06-09T03:50:18.000Z","comments":true,"path":"demos/marching ants borders.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/marching ants borders.html","excerpt":"","text":"@keyframes ants { to { background-position: 100%; } } .marching-ants-borders { width: 10em; height: 10em; margin: 2em 0; border: 1px solid transparent; background: linear-gradient(white, white) padding-box, repeating-linear-gradient(-45deg, #000 0, #000 25%, #fff 0, #fff 50%) 0 / .6em .6em; animation: ants 12s linear infinite; }"},{"title":"","date":"2016-06-09T03:27:36.000Z","updated":"2016-06-09T03:27:36.000Z","comments":true,"path":"demos/transform-origin.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/transform-origin.html","excerpt":"","text":".demo1 { width: 150px; height: 200px; position: relative; } .demo1 .box1, .demo1 .box2 { top: 25px; width: 100px; height: 100px; position: absolute; } .demo1 .box1 { border: 1px dotted #000; } .demo1 .box2 { border: 1px solid #000; transform: translate(40px, 40px); -webkit-transform: translate(40px, 40px); transform-origin: 50% 50%; -webkit-transform-origin: 50% 50%; } 示例1 .demo2 { width: 150px; height: 200px; position: relative; } .demo2 .box1, .demo2 .box2 { top: 25px; width: 100px; height: 100px; position: absolute; } .demo2 .box1 { border: 1px dotted #000; } .demo2 .box2 { border: 1px solid #000; transform: translate(40px, 40px); -webkit-transform: translate(40px, 40px); transform-origin: 100% 100%; -webkit-transform-origin: 100% 100%; } 示例2"},{"title":"","date":"2016-06-09T03:30:04.000Z","updated":"2016-06-09T03:30:04.000Z","comments":true,"path":"demos/transform-style.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/transform-style.html","excerpt":"","text":".demo4 { position: relative; width: 200px; height: 200px; perspective: 200px; -webkit-perspective: 200px; } .demo4 .container1, .demo4 .container1-origin { position: absolute; width: 100px; height: 100px; } .demo4 .container1-origin, .demo4 .container1 { left: 40px; top: 40px; } .demo4 .container1-origin { border: 1px dotted #000; } .demo4 .container1 { border: 1px solid #000; transform: rotateY(40deg); -webkit-transform: rotateY(40deg); transform-style: flat; -webkit-transform-style: flat; } .demo4 .container1 .box { border: 1px solid #f00; width: 50px; height: 50px; transform: rotateY(40deg); -webkit-transform: rotateY(40deg); } .demo5 { position: relative; width: 200px; height: 200px; perspective: 200px; -webkit-perspective: 200px; } .demo5 .container1, .demo5 .container1-origin { position: absolute; width: 100px; height: 100px; } .demo5 .container1-origin, .demo5 .container1 { left: 40px; top: 40px; } .demo5 .container1-origin { border: 1px dotted #000; } .demo5 .container1 { border: 1px solid #000; transform: rotateY(40deg); -webkit-transform: rotateY(40deg); transform-style: preserve-3d; -webkit-transform-style: preserve-3d; } .demo5 .container1 .box { border: 1px solid #f00; width: 50px; height: 50px; transform: rotateY(40deg); -webkit-transform: rotateY(40deg); }"},{"title":"","date":"2016-06-09T03:35:23.000Z","updated":"2016-06-09T03:35:23.000Z","comments":true,"path":"demos/空心字1.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/空心字1.html","excerpt":"","text":"@keyframes shadow { 0% { text-shadow: 0px 0px 0px #f00; } 50% { text-shadow: 0px 0px 10px #f00; } 100% { text-shadow: 0px 0px 0px #f00; } } .kongxinzi1 { font-size: 5em; font-weight: bold; font-family: sans-serif; color: #fff; animation: shadow 5s linear infinite; } 空心字"},{"title":"","date":"2016-06-09T03:36:54.000Z","updated":"2016-06-09T03:36:54.000Z","comments":true,"path":"demos/空心字2.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/空心字2.html","excerpt":"","text":".kongxinzi2 span { position: absolute; color: transparent; background-image: repeating-linear-gradient(to bottom, #f00 0%, #000 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } .kongxinzi2:after, .kongxinzi2 span { font-size: 5em; font-weight: bold; font-family: monospace; } .kongxinzi2:after { content: attr(title); text-shadow: 0px 0px 1px #1e1414; color: transparent; } BARCITO"},{"title":"","date":"2016-12-15T15:17:51.000Z","updated":"2016-12-15T15:17:51.000Z","comments":true,"path":"demos/2016-12-15/form1.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/2016-12-15/form1.html","excerpt":"","text":".form1 .form-row::after { content: ' '; display: block; width: 0; height: 0; clear: both; } .form1 .form-key, .form1 .form-value { float: left; height: 30px; line-height: 30px; padding: 4px 0; } .form1 .form-key { width: 80px; text-align: right; padding-right: 10px; } .form1 .form-value input { box-sizing: border-box; height: 30px; } .form1 .form-operations { padding-left: 90px; } 用户名 手机号 验证码 密码 阅读并接受《百度用户协议》 注册"},{"title":"","date":"2016-12-15T15:20:22.000Z","updated":"2016-12-15T15:20:22.000Z","comments":true,"path":"demos/2016-12-15/form2.html","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/demos/2016-12-15/form2.html","excerpt":"","text":".form2 .form { display: table; } .form2 .form-row, .form2 .form-operations { display: table-row; } .form2 .form-key, .form2 .form-value { display: table-cell; padding: 4px 0; } .form2 .form-key { text-align: right; padding-right: 10px; } .form2 .form-value input { box-sizing: border-box; height: 30px; } .form2 .form-operations::before { content: ''; display: table-cell; } 用户名 手机号 验证码 密码 阅读并接受《百度用户协议》 注册"}],"posts":[{"title":"ES6 中的模式匹配和默认参数","slug":"ES6 模式匹配和默认参数","date":"2017-01-05T16:00:00.000Z","updated":"2017-01-06T10:05:40.000Z","comments":true,"path":"blogs/ES6 模式匹配和默认参数.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/ES6 模式匹配和默认参数.html","excerpt":"ES6 中，引入了其他很多语言都具备的模式匹配和默认参数语法糖，使得代码简洁了不少。但是使用的时候还是有些细节需要注意。","text":"ES6 中，引入了其他很多语言都具备的模式匹配和默认参数语法糖，使得代码简洁了不少。但是使用的时候还是有些细节需要注意。 模式匹配原理模式匹配的种类具体来说，有三种类型的模式匹配： 直接赋值 1let a = 1; 对象模式 1let &#123;name, age: age&#125; = &#123;name: 'yibuyisheng', age: 25&#125;; 数组模式 1let [a, b] = [1, 2]; 模式匹配的过程 直接赋值：x ← value（包括 undefined 和 null） 1x = value 对象模式 该种模式下，会检查匹配源是不是对象，如果不是对象，则会使用内部的 ToObject() 进行转换。 {«properties»} ← undefined 1throw new TypeError(); {«properties»} ← null 1throw new TypeError(); {key: «pattern», «properties»} ← obj 12«pattern» ← obj.key&#123;«properties»&#125; ← obj {key: «pattern» = default_value, «properties»} ← obj 1234567let tmp = obj.key;if (tmp !== undefined) &#123; «pattern» ← tmp&#125; else &#123; «pattern» ← default_value&#125;&#123;«properties»&#125; ← obj {} ← obj 1// No properties left, nothing to do 数组模式 该种模式下，右侧必须是可迭代的，如果不可迭代，就会抛出错误。 [«elements»] ← non_iterable 12assert(!isIterable(non_iterable))throw new TypeError(); [«elements»] ← iterable 123assert(isIterable(iterable))let iterator = iterable[Symbol.iterator]();«elements» ← iterator 模式匹配中需要注意的undefined 触发默认值如下所示： 1let [x = 1] = [undefined]; // x = 1 右侧的 underfined 元素会触发左侧的默认值。 在需要的时候才会去计算默认值比如： 1let &#123;prop: y = someFunc()&#125; = someValue; 只有在右侧 someValue.prop 为 undefined 的时候才会执行 someFunc() 函数。 模式匹配中可以引用模式中前面的变量比如： 1let [x = 3, y = x] = [7, 2]; // x=7; y=2 这个地方要注意顺序，比如下面这个就是错误的： 1let [x = y, y = 3] = [7, 2]; // ReferenceError 函数参数传递函数传参的过程，实际上就包含了模式匹配的过程： 12345678910111213function func(«FORMAL_PARAMETERS») &#123; «CODE»&#125;func(«ACTUAL_PARAMETERS»);// 大致是：&#123; let [«FORMAL_PARAMETERS»] = [«ACTUAL_PARAMETERS»]; &#123; «CODE» &#125;&#125; 函数默认参数，慎用对象引用有如下示例代码： 12345678let list = [];function fn(a = list) &#123; console.log(a);&#125;fn(); // console.log: []list.push(1);fn(); // console.log: [1] 默认参数使用了 list 引用，那么后续对 list 的修改，都会体现到默认参数上面去。在大型项目开发中，容易失控。如果一定要用某个变量生成默认值，建议深拷贝一份： 12345let list = [];const listDefaultParam = deepClone(list); // 其它地方不要再使用这个变量了，并且在函数内部也不要修改这个变量值function fn(a = listDefaultParam) &#123; console.log(a);&#125; 默认参数的作用域使用最新版的 Chrome 浏览器执行下面的代码，注意输出结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344(&#123; method() &#123; function innerFn(a = () =&gt; console.log(this)) &#123; a(); &#125; innerFn.call(this); &#125;&#125;).method();(&#123; method() &#123; function innerFn(a = () =&gt; console.log(this)) &#123; a(); &#125; innerFn(); &#125;&#125;).method();(&#123; method() &#123; let arrowFn = () =&gt; console.log(this); function innerFn(a = arrowFn) &#123; a(); &#125; innerFn(); &#125;&#125;).method();(&#123; method() &#123; let arrowFn = () =&gt; console.log(this); function innerFn(a = arrowFn) &#123; a(); &#125; innerFn.call(this); &#125;&#125;).method();// output://// Object(&#123;method: ()&#125;)// Window &#123; ... &#125;// Object(&#123;method: ()&#125;)// Object(&#123;method: ()&#125;) 实际上，将上述代码用 babel 转换一下，可以发现默认参数的处理过程发生在函数开始部分。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"}],"keywords":[]},{"title":"当心，babel 处理 Symbol 的麻烦","slug":"当心，babel 处理 Symbol 的麻烦","date":"2016-12-28T14:29:00.000Z","updated":"2016-12-28T15:15:54.000Z","comments":true,"path":"blogs/当心，babel 处理 Symbol 的麻烦.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/当心，babel 处理 Symbol 的麻烦.html","excerpt":"在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。","text":"在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。 有的团队为了避免引入这个额外的 polyfill ，会选择不使用 Symbol ，包括通过 babel 生成 Symbol 的特性（比如 for of 等）。 这时候就会有个比较隐蔽的地方需要注意，就是尽量不要让 babel 生成这样的代码： 1var _typeof = typeof Symbol === \"function\" &amp;&amp; typeof Symbol.iterator === \"symbol\" ? function (obj) &#123; return typeof obj; &#125; : function (obj) &#123; return obj &amp;&amp; typeof Symbol === \"function\" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? \"symbol\" : typeof obj; &#125;; 这个里面包含了一个 Symbol ，为了让 Symbol 不至于报错，又要想办法在全局先声明一下 Symbol 变量，比较丑陋。 目前在实践中，发现这样的 ES next 代码会生成上述代码： 123456789function fn1() &#123; if (1) &#123; let a = 1; filter(function fn() &#123; console.log(a); &#125;); return; &#125;&#125; 生成的代码为： 12345678910111213141516171819\"use strict\";var _typeof = typeof Symbol === \"function\" &amp;&amp; typeof Symbol.iterator === \"symbol\" ? function (obj) &#123; return typeof obj; &#125; : function (obj) &#123; return obj &amp;&amp; typeof Symbol === \"function\" &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? \"symbol\" : typeof obj; &#125;;function fn1() &#123; if (1) &#123; var _ret = function () &#123; var a = 1; filter(function fn() &#123; console.log(a); &#125;); return &#123; v: void 0 &#125;; &#125;(); if ((typeof _ret === \"undefined\" ? \"undefined\" : _typeof(_ret)) === \"object\") return _ret.v; &#125;&#125; 这段代码有什么特征呢？就是在 if 块中定义了函数，函数中访问了 if 块中的“块级变量”，并且 if 块使用了 return 语句。 可以看出，babel 为了保证 if 块内变量的作用域，会套一个匿名函数，同时由于 if 块中存在 return 返回，所以就用 _ret 来接收匿名函数的返回值。然后后面为啥会生成那串长长的对 _ret 的类型判断代码，目前还不太清楚，可能要结合 babel 的内部处理逻辑去看了，单从生成的代码看，这个完全是多余的。 推而广之， for 块等局部非函数作用域都会有类似的问题。 实际上，从代码编写规范角度来看，是不应该在这种局部作用域块里面定义函数的。函数应该是一段通用的代码，不应该缩在那一小块里面。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"babel","slug":"babel","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/babel/"}],"keywords":[]},{"title":"Redux 使用初探","slug":"Redux 使用初探","date":"2016-12-25T16:00:00.000Z","updated":"2016-12-26T11:07:18.000Z","comments":true,"path":"blogs/Redux 使用初探.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/Redux 使用初探.html","excerpt":"Redux 提供的主要功能：全局数据管理，包括数据的更新、存储、数据变化通知。 Redux 的 store 中存放了当前应用的状态，可以根据这个状态完整恢复出当前应用的界面，因此在使用 Redux 的项目中，可以实现一个比较炫酷的功能：依据状态的前进、后退。","text":"Redux 提供的主要功能：全局数据管理，包括数据的更新、存储、数据变化通知。 Redux 的 store 中存放了当前应用的状态，可以根据这个状态完整恢复出当前应用的界面，因此在使用 Redux 的项目中，可以实现一个比较炫酷的功能：依据状态的前进、后退。 Redux 中主要有三大块： Action：指代引起 Redux 中数据变化的操作； Reducer：响应 Action 操作，修改 Redux 中的数据； Store：包含一个 state 对象，用于存放整个应用的数据，并整合将 Action 和 Reducer 整合起来，修改 Store 中的数据。 目前，网上已经有很多中文资料介绍具体概念细节以及相关 API 了，比如： Redux 中文文档 React 数据流管理架构之 Redux 介绍 这里主要想记录一下作为一个初学 Redux 的菜鸟，使用过程中的心得体会。 单单就 Redux 本身来看，并不能直接用于生产，太灵活了，有很多“套路”需要强制定下来： 怎么设计 state 对象的数据结构？怎么分好模块？怎么规定各个模块的命名风格？ Redux 只提供了注册 state 变化回调函数的 API ，如果只想监听其中某一个数据的变化该怎么办？ 如果在 state change 的回调函数中再次 dispatch Action ，就可能造成无限递归，怎么设计才能很好地避免这种无限递归？ 如何设计组织项目代码才更好维护？ 如何避免写大量重复的 Action 、 Reducer 代码？ 划分代码目录目录的划分方式有多种，可以按照项目的功能模块，也可以按照 Redux 的职责模块。我选择了后者，采用的目录结构如下： 外部可以直接引入的 JS 模块只能是 data/main 和 data/actionTypes 。 解决递归调用为什么会有递归调用呢？参考如下代码： 1234567891011121314151617181920212223import &#123;createStore&#125; from 'redux';function reducer(state = &#123;&#125;, action) &#123; switch (action.type) &#123; case 'SOME_THING_LOAD_COMPLETE': return Object.assign(&#123;&#125;, state, &#123; loadComplete: true &#125;); default: return state; &#125;&#125;let store = createStore(reducer);store.subscribe(() =&gt; // do something here. store.dispatch(&#123;type: 'SOME_THING_LOAD_COMPLETE'&#125;););store.dispatch(&#123;type: 'SOME_THING_LOAD_COMPLETE'&#125;); 上面这个简单的例子很清晰地说明了无限递归的问题，在实际开发中，由于业务逻辑的复杂纠缠，这个递归过程可能非常间接、隐蔽，造成 debug 困难。那么如何有效避免呢？ 一个比较常用的方法就是检查对应数据是否真的发生了变化，比如上面的代码可以改为： 12345678910111213141516171819202122232425262728import &#123;createStore&#125; from 'redux';function reducer(state = &#123;&#125;, action) &#123; switch (action.type) &#123; case 'SOME_THING_LOAD_COMPLETE': return Object.assign(&#123;&#125;, state, &#123; loadComplete: true &#125;); default: return state; &#125;&#125;let store = createStore(reducer);let previousLoadComplete;store.subscribe(() =&gt; // do something here. let currentLoadComplete = store.getState().loadComplete; if (currentLoadComplete !== previousLoadComplete) &#123; store.dispatch(&#123;type: 'SOME_THING_LOAD_COMPLETE'&#125;); previousLoadComplete = currentLoadComplete; &#125;);store.dispatch(&#123;type: 'SOME_THING_LOAD_COMPLETE'&#125;); 由于 state 每次更新都会在相应位置产生一个新对象，所以只需要用全等来判断就行了。 组织 state 数据结构如何划分 state 对象的结构呢？可能每个人根据自己的经验，都有自己的一套划分方式。此处我采用了与业务功能模块对齐的原则。 比如，我的项目里面有这样一些页面：用户列表页面、用户详情页面、资源页面、资源详情页面，那么 state 对象的结构为： 123456state = &#123; 'user.list': &#123; ... &#125;, 'user.detail': &#123; ... &#125;, 'resource.list': &#123; ... &#125;, 'resource.detail': &#123; ... &#125;&#125; 结构扁平化了。 个人建议，不要使用“多层”的 state 结构，比如把上面的例子设计成： 1234567891011// BADstate = &#123; user: &#123; list: &#123; ... &#125;, detail: &#123; ... &#125; &#125;, resource: &#123; list: &#123; ... &#125;, detail: &#123; ... &#125; &#125;&#125;; 过深的结构会带来不必要的复杂度。 扩展事件监听方式Redux 只提供了 subscribe 方法来监听 state 的变化，在实际开发中，某一个组件可能只对某部分 state 变化感兴趣。所以，应当适当地做一下扩展： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106export default class StateWatcher &#123; /** * 存放监听回调函数等 * * @private * @type &#123;Array.&lt;Object&gt;&#125; */ watcherList = []; /** * 构造函数 * * @constructor * @param &#123;store&#125; Store Redux store实例 */ constructor(store) &#123; this.store = store; // 存放之前 state this.previousStoreState = extend(&#123;&#125;, this.store.getState()); this.subscribe(); &#125; /** * 订阅 store 中 state 变化事件，会去检查 watcherList 中是否存在相应数据变化的回调函数 * * @private */ subscribe() &#123; let me = this; this.unsubscribe = this.store.subscribe(function () &#123; let currentStoreState = me.store.getState(); let changedPropertyNameList = []; let delayFns = []; // 遍历 watcherList ，查找注册的回调函数 each(me.watcherList, watcher =&gt; &#123; let propertyName = watcher.propertyName; let previous = me.previousStoreState[propertyName]; if (currentStoreState[propertyName] !== previous) &#123; changedPropertyNameList.push(propertyName); // 这里 context 对应的是某个组件，如果组件销毁了，就没有必要调用相应回调函数了。 if (!watcher.context.isInStage(componentState.DESTROIED)) &#123; // 回调函数得延迟执行，因为回调函数是不可控的，在回调函数中可能又 dispatch 另外的 action ， // 那就相当于此次 action 还没处理完，新的又来了，容易造成莫名其妙的错误。 // 所以要秉承处理完当前 action 的前提下，才能处理下个 action 的原则。 delayFns.push(() =&gt; &#123; watcher.watcherFn.call( watcher.context, propertyName, currentStoreState[propertyName], previous ); &#125;); &#125; &#125; &#125;); // 统一更新属性 each(changedPropertyNameList, propertyName =&gt; &#123; me.previousStoreState[propertyName] = currentStoreState[propertyName]; &#125;); // action 处理完之后，统一调用延迟函数。 each(delayFns, fn =&gt; fn()); &#125;); &#125; /** * 添加属性变化的回调函数 * * @public * @param &#123;string&#125; propertyName 属性名 * @param &#123;Function&#125; watcherFn 回调函数 * @param &#123;Component&#125; context 组件 */ addWatcher(&#123;propertyName, watcherFn, context&#125;) &#123; this.watcherList.push(&#123;propertyName, watcherFn, context&#125;); &#125; /** * 移除属性变化的回调函数 * * @public * @param &#123;string&#125; propertyName 属性名 * @param &#123;Function&#125; watcherFn 回调函数 * @param &#123;Component&#125; context 组件 */ removeWatcher(&#123;propertyName, watcherFn, context&#125;) &#123; this.watcherList = filter(this.watcherList, watcher =&gt; &#123; return watcher.propertyName !== propertyName || watcher.watcherFn !== watcherFn || watcher.context !== context; &#125;); &#125; /** * 销毁 * * @public */ destroy() &#123; this.unsubscribe(); &#125;&#125; 避免写重复代码目前想到的，就只是抽离复用代码，形成 helper 方法之类的。 最后本文所述方案仅供参考，算是我初次使用 Redux 所想到的一些“套路”，不对之处静候读者指出，共同探讨。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"Redux","slug":"Redux","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/Redux/"}],"keywords":[]},{"title":"如何展示表单控件","slug":"如何展示表单控件","date":"2016-12-15T14:34:00.000Z","updated":"2016-12-15T15:34:16.000Z","comments":true,"path":"blogs/如何展示表单控件.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/如何展示表单控件.html","excerpt":"在 Web 开发中，经常需要展示左右结构的表单。","text":"在 Web 开发中，经常需要展示左右结构的表单。如下所示： 面对这张图，最先想到的实现方式就是借助浮动： 基本的结构就这样，看起来挺好的。 但是有一个忧伤的地方，左侧form-key部分的宽度太烦人，不同的表单form-key部分存在宽度差异，很难统一。如果把form-key部分统一设置成一个比较大的值，那么在form-key比较短的表单里面会非常难看。这样一来，只能选择不同的表单设置不同的form-key的宽度值，很烦人。 如何让左侧的宽度自适应呢？ 从一位前端牛人学习到如下利用table布局的写法： 此处form-operations部分有点小问题，form-operations是一个table-row，所以直接子元素应该是table-cell，改一改就好了。 同时也因为这个手误，发现在 IE9 中，鼠标 hover 到table-row上面去之后，会触发下面第一个button的 hover 效果。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"HTTP请求重发","slug":"HTTP请求重发","date":"2016-07-05T16:00:00.000Z","updated":"2016-07-08T08:07:25.000Z","comments":true,"path":"blogs/HTTP请求重发.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/HTTP请求重发.html","excerpt":"HTTP 协议中，从语义上讲， GET 请求一般是获取服务器端的资源，不会对服务器数据造成副作用，可简单理解为一种“读”操作；而 POST 请求多用于更改（增、删、改）服务器上的资源，会产生一定的副作用。 所以，这样看起来，浏览器是不是就不会因为网络原因啥的自动重发 POST 请求吧？实际上是这样么？","text":"HTTP 协议中，从语义上讲， GET 请求一般是获取服务器端的资源，不会对服务器数据造成副作用，可简单理解为一种“读”操作；而 POST 请求多用于更改（增、删、改）服务器上的资源，会产生一定的副作用。 所以，这样看起来，浏览器是不是就不会因为网络原因啥的自动重发 POST 请求吧？实际上是这样么？ 起因最近在对接地图的一个数据录入接口：前端向后端发送一个 CSV 文件，后端将 CSV 文件中的数据解析出来，然后将数据通过地图接口导入到地图数据库。由于地图提供的接口有点怪异，批量导入数据的接口有一些问题，只能使用单条导入接口，所以在这里， CSV 文件里面有多少条数据，就会访问多少次地图的接口。 虽然有点坑，不过问题究竟是解决了，于是就这样上线了。 天有不测风云，遇到一个客户，一下要导入上千条数据，后端这样串行地一条一条去导入，很轻易地就花了好几分钟。而且还遇到一个诡异的现象：每条数据都导入了两次！ 分析凭借多年的前端开发经验（不要脸了），立马大胆猜测，浏览器发送了两次请求。 于是先到谷歌开发者工具的 Network 标签页检查一下请求，发现此处只记录了一次请求，并且该请求没有响应，好像看不出来什么猫腻。再切换到 chrome://net-internals/ 中看看日志，发现一个 error code ， google 了一下，并没有什么结果，看起来也验证不了猜想。 然后再去找后端同学看看接口日志，是不是访问了两次，后端同学似乎稍微有点不太想打日志重新部署（过程比较麻烦），所以先放弃用这种方式求证。 那用啥求证呢？ Charles 吧。 在 Charles 中一看，发现发了四次请求，每次请求基本上都耗时六十多秒，每次都没有响应内容。 好了，看起来就是浏览器六十秒超时重发请求。 深入分析可以转念一想，这对么？ 1、 POST 请求就这样轻易地被浏览器超时重发，难道浏览器开发者没考虑过数据重复发送的问题吗？表单 POST 请求手动刷新浏览器的时候都会弹窗提醒用户要不要重复提交数据呢！ 2、为啥是六十秒呢？时间这么短吗？想想平时本地断点调试服务器代码的时候，那可是会超时老长时间的，所以这六十秒算个啥呢？ 搜一搜往上资料，发现 HTTP/1.1 的一处规范 ： If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the “100-continue” expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request. 大致意思就是说，如果发送一个请求到服务器端，该请求有请求体，但是请求头里面不包含“ 100-continue ”这种东西，并且客户端没有直接连接到原始的 HTTP/1.1 服务器，此时，如果客户端在接收到服务器发送的 HTTP 状态之前发现服务器主动关掉连接，那么客户端应该重试请求。 那看起来好像就是服务器端主动关掉了连接，导致浏览器重新发送请求了。 我们服务器端使用的是 Tomcat ，查一查资料，发现 Tomcat 默认的 connector 超时时间是六十秒，刚好吻合上了。 问题原因找到了，解决起来就轻松了，此处不赘述。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/HTTP/"}],"keywords":[]},{"title":"karma 入门","slug":"karma-入门","date":"2016-07-01T02:35:44.000Z","updated":"2016-07-01T03:56:25.000Z","comments":true,"path":"blogs/karma-入门.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/karma-入门.html","excerpt":"本文介绍了 karma 的入门知识点。","text":"本文介绍了 karma 的入门知识点。 什么是 karmakarma 是一个提升测试效率的工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。 安装 karma可以通过 npm 安装 karma ： 12345// 本地安装npm i karma --save-dev// 全局安装npm i karma -g 初始化 karma安装完成之后，切换到目标项目根目录，运行： 1karma init 这样就会以向导的形式生成 karma 的配置文件 karma.conf.js ，文件内容大致为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192// Karma configuration// Generated on Wed Jun 29 2016 23:22:24 GMT+0800 (CST)module.exports = function(config) &#123; config.set(&#123; // 根路径，后面配置的基本所有相对路径都会根据这个路径来构造。 basePath: '', // 使用到的框架 // 目前支持的框架： https://npmjs.org/browse/keyword/karma-adapter frameworks: ['jasmine', 'requirejs'], // 将会在浏览器里面执行的代码 files: [ 'test/main.js', &#123; pattern: 'src/**/*.js', // false 表示初始化的时候不会使用 script 标签直接将相关 js 引入到浏览器，需要自己写代码加载 included: false &#125;, &#123; pattern: 'test/**/*Spec.js', included: false &#125; ], // 需要从 files 中排除掉的文件 exclude: [], // 需要做预处理的文件，以及这些文件对应的预处理器。 // 此处就可以将 coffee 、 ES6 等代码转换一下。 preprocessors: &#123; 'src/**/*.js': ['babel', 'coverage'], 'test/**/!(main).js': ['babel', 'coverage'], 'node_modules/protectobject/src/**/*.js': ['babel'] &#125;, // babel 预处理器的配置 babelPreprocessor: &#123; options: &#123; presets: ['es2015', 'stage-0'], plugins: ['transform-decorators-legacy', 'transform-es2015-modules-amd'] &#125; &#125;, // 覆盖率报告器配置 coverageReporter: &#123; type: 'html', dir: 'coverage' &#125;, // 实际使用的报告期 // 可用的报告器： https://npmjs.org/browse/keyword/karma-reporter reporters: ['dots', 'coverage'], // 服务器端口号 port: 9876, // 在输出内容（报告器和日志）中启用/禁用颜色 colors: true, // 日志级别 // 取值： config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG logLevel: config.LOG_INFO, // 启用/禁用监视文件变化重新执行测试的功能 autoWatch: true, // 要测试的目标环境 browsers: ['Chrome', 'Firefox', 'Safari'], // Continuous Integration mode // if true, Karma captures browsers, runs the tests and exits singleRun: false, // Concurrency level // how many browser should be started simultaneous concurrency: Infinity &#125;);&#125;; 配置 Require.js对于 Require.js ，还要注意配置一个入口文件，主要用于配置 Require.js 的模块信息等。 上述 karma 配置文件中的 test/main.js 即为 Require.js 的入口文件，在该文件中的代码一般来说应该是这样的： 12345678910111213141516171819202122232425262728293031323334353637var TEST_REGEXP = /(spec|test)\\.js$/i;var allTestFiles = [];// Get a list of all the test files to includeObject.keys(window.__karma__.files).forEach(function(file) &#123; if (TEST_REGEXP.test(file)) &#123; // Normalize paths to RequireJS module names. // If you require sub-dependencies of test files to be loaded as-is (requiring file extension) // then do not normalize the paths var normalizedTestModule = file.replace(/^\\/base\\/|\\.js$/g, ''); allTestFiles.push(normalizedTestModule); &#125;&#125;);require.config(&#123; // Karma serves files under /base, which is the basePath from your config file baseUrl: '/base/src', // example of using a couple of path translations (paths), to allow us to refer to different library dependencies, without using relative paths paths: &#123; 'jquery': '../lib/jquery', 'underscore': '../lib/underscore', &#125;, // example of using a shim, to load non AMD libraries (such as underscore) shim: &#123; 'underscore': &#123; exports: '_' &#125; &#125;, // dynamically load all test files deps: allTestFiles, // we have to kickoff jasmine, as it is asynchronous callback: window.__karma__.start&#125;); 执行测试运行如下命令，执行测试： 1karma start karma 分析在执行测试的时候，点击 debug 按钮，进入 debug 页面，然后打开浏览器开发者工具，可以看到在 HTML 中有一段 js 代码： 123456789101112131415// Configure our Karma window.__karma__.config = &#123;\"args\":[],\"useIframe\":true,\"captureConsole\":true,\"clearContext\":true&#125;; // All served files with the latest timestamps window.__karma__.files = &#123; '/base/node_modules/requirejs/require.js': '2c8b45573db27c131094a113e995236d20f043bb', '/base/node_modules/karma-requirejs/lib/adapter.js': '2621a4400d4a8a49588243fce2d8609ef950b46a', '/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js': '391e45351df9ee35392d2e5cb623221a969fc009', '/base/node_modules/karma-jasmine/lib/boot.js': '945a38bf4e45ad2770eb94868231905a04a0bd3e', '/base/node_modules/karma-jasmine/lib/adapter.js': '7975a273517f1eb29d7bd018790fd4c7b9a485d5', '/base/test/main.js': 'fc5206f4dff3b583db818cb10ed7c5cade572896', '/base/src/State.js': 'db89a58b4570983b8f8febfd4dedbc586c353670', '/base/test/StateSpec.js': 'faf31b373690a6d7a7035fdfdc9c85d906ace5c1'&#125;; 可以看到 window.__karma__.files 中列出了所有的可能会在浏览器中执行的 js ，如果通过 Require.js 加载这里没有列举出来的 js ，就会报错。 然后再看下面的一堆 script 标签，大致是这样的： 123456789&lt;script type=\"text/javascript\" src=\"/base/node_modules/requirejs/require.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/base/node_modules/karma-requirejs/lib/adapter.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/base/node_modules/karma-jasmine/lib/boot.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/base/node_modules/karma-jasmine/lib/adapter.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/base/test/main.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.__karma__.loaded(); &lt;/script&gt; 可以看到，直接引入了 require.js 、 karma 相关的一堆 js 、jasmine 相关的 js ，还直接引入了刚才配置的 test/main.js （Require.js 入口文件）。注意，此处并没有直接引入 included: false 的 js 。 URL 路径中的 base如果仔细看各种资源请求的 URL 地址，会发现除了 debug.js 和 context.js 之外，其它 js 文件都会以 /base 开头，在配置 Require.js 的时候，务必注意这一点。 coverage可以引入 karma 的 coverage 插件来查看测试覆盖率，该插件会在目标代码中插入很多额外的代码，用于判断测试代码执行流程有没有走到这些地方。在 debug 的时候，最好关掉 coverage 功能，不然这些额外的代码非常影响调试。 另外 karma-coverage-es6 声称支持 ES6 ，但是似乎并不行？ jasmine 的 HTML reporter默认情况下，浏览器中 debug 页面是不会输出任何 jamine 测试结果的，可以借助 karma-jasmine-html-reporter 解决这个问题。 但是，karma-jasmine-html-reporter 有坑，在该插件的 index.js 中，有这样一段代码： 123456789101112131415161718var createPattern = function(path) &#123; return &#123;pattern: path, included: true, served: true, watched: false&#125;;&#125;;var initReporter = function(files, baseReporterDecorator) &#123; baseReporterDecorator(this); files.unshift(createPattern(__dirname + '/lib/adapter.js')); files.unshift(createPattern(__dirname + '/lib/html.jasmine.reporter.js')); files.unshift(createPattern(__dirname + '/css/jasmine.css'));&#125;;initReporter.$inject = ['config.files', 'baseReporterDecorator'];module.exports = &#123; 'reporter:kjhtml': ['type', initReporter]&#125;; files 指的就是 karma.conf.js 中配置的 files ，此处使用 unshift 方法将这堆 js 、 css 放在了 files 最前面，这样就会导致 html.jasmine.reporter.js 先于 jasmine.js 加载，从而报错（html.jasmine.reporter.js 是要依赖 jasmine.js 的），所以这里最好根据项目的实际情况，合理调整一下顺序。","categories":[],"tags":[],"keywords":[]},{"title":"受保护的对象","slug":"受保护的对象","date":"2016-06-19T08:27:44.000Z","updated":"2016-07-01T03:56:57.000Z","comments":true,"path":"blogs/受保护的对象.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/受保护的对象.html","excerpt":"虽然 JavaScript 没有多线程变量共享的问题，但是在一些场景中，我们还是希望能对某些对象进行适当的保护（锁定），防止发生一些不可预期的错误。 本文主要从如下两个实际场景展开： 任务执行器； 事件基类。","text":"虽然 JavaScript 没有多线程变量共享的问题，但是在一些场景中，我们还是希望能对某些对象进行适当的保护（锁定），防止发生一些不可预期的错误。 本文主要从如下两个实际场景展开： 任务执行器； 事件基类。 任务执行器现在，我们需要一个 DOM 操作的任务执行器，这个任务执行器满足的主要功能有： 能够添加任务； 能够批量执行任务； 能够随时启动和停止任务的执行。 为啥需要这么个东西呢？假设其中有下面三步 DOM 操作： 设置节点 a 的文本： a.innerText = &#39;text1&#39; ； 设置节点 a 的文本： a.innerText = &#39;text2&#39; ； 设置节点 a 的文本： a.innerText = &#39;text3&#39; 。 如果老老实实设置三次，感觉太不划算了！实际上只需要设置最后一次就好了，这样就可以减少两次无谓的 DOM 操作了。 初步看起来，我们的任务执行器代码大致会像这个样子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798const TASKS = Symbol('tasks');const COUNTER = Symbol('counter');const EXECUTE = Symbol('execute');const IS_RUNNING = Symbol('isRunning');export default class DomUpdater &#123; constructor() &#123; this[TASKS] = &#123;&#125;; this[COUNTER] = 0; &#125; /** * 获取任务ID，每一种类型操作对应一个任务ID， * 比如对某个节点的innerText就可以算是一种类型的操作，具有唯一的任务ID * * @public * @return &#123;string&#125; 任务ID */ getTaskId() &#123; return '' + ++this[COUNTER]; &#125; /** * 添加任务函数 * * @public * @param &#123;Function&#125; taskFn 任务函数 * @param &#123;Function&#125; notifyFn 任务执行完成之后的回调函数 */ add(taskId, taskFn, notifyFn) &#123; const task = this[TASKS][taskId] || &#123;&#125;; task.taskFn = taskFn; // 为啥notifyFns会是一个数组，而taskFn不是数组呢？ // 因为我们期望后续同类型的（taskId相同）的任务能够覆盖掉之前的任务， // 而之前任务的回调函数需要保留，这样就可以保证一定会通知外界某个任务已经执行完成了。 task.notifyFns = task.notifyFns || []; task.notifyFns.push(notifyFn); this[TASKS][taskId] = task; this[EXECUTE](); &#125; /** * 启动任务执行 * * @public */ start() &#123; this[IS_RUNNING] = true; this[EXECUTE](); &#125; stop() &#123; this[IS_RUNNING] = false; &#125; /** * 执行任务 * * @private */ [EXECUTE]() &#123; if (!this[IS_RUNNING]) &#123; return; &#125; window.requestAnimationFrame(() =&gt; &#123; for (let taskId in this[TASKS]) &#123; const task = this[TASKS][taskId]; if (!task) &#123; continue; &#125; let result; let error; try &#123; result = task.taskFn(); &#125; catch (err) &#123; error = err; &#125; for (let i = 0, il = task.notifyFns.length; i &lt; il; ++i) &#123; task.notifyFns[i](error, result); &#125; this[TASKS][taskId] = null; &#125; &#125;); &#125; destroy() &#123; this[TASKS] = null; &#125;&#125; 好了，看起来似乎可以了，那就到实际环境遛遛吧！ 不遛不知道，一遛吓一跳，跳出来一些莫名其妙的问题： 代码的第90行报this[TASKS]不存在； 总是会有任务的回调函数没有被调用。 仔细分析一下代码，可以发现： 对于第一个问题，在执行传入 requestAnimationFrame 的回调函数的时候，某个 taskFn 或者 notifyFn 可能会调用 destroy() 方法，从而将 this[TASKS] 设为了 false ，然后再执行到90行，就报错了。 对于第二个问题，假设有两个同类型的任务，在 ‘EXECUTE’ 中调用第一个任务的 notifyFn 的时候，添加进第二个任务（调用了 add() 方法），然后执行到90行，将该类型任务置为 null ，这样一来，第二个任务的回调函数就没有机会执行了。 所以，问题的根源就在任务执行过程中调用了不可控的外部函数，从而导致 this[TASKS] 发生变化。 对于第一个类型的问题，可以简单地使用 IS_RUNNING 状态绕开。对于第二种类型的问题，就最好找一种更优雅通用的解决方案了。 我们注意到，传入 requestAnimationFrame 的回调函数体（行范围：[72-90]）是一个敏感地带，执行这块代码的时候，应该将 this[TASKS] 锁定，防止不可控的外部函数（ taskFn 和 notifyFn ）对其进行干扰。 其实简单说起来，这类问题就是 for in 循环中，被遍历的对象应该是可读的的一个变体，所以，可以抽离出来一个比较通用的类，具体实现代码请移步到这里。 现在，我们的DOM 操作任务执行器看起来就像这样了。 目前看来，这个 DomUpdater 还有些小地方需要优化： TASKS 任务遍历顺序不应该依赖于对象上键的遍历顺序。 TASKS 对象的键并没有销毁，所以每次任务执行的时候，遍历次数都会只增不减。 事件基类在搭建前端框架的时候，一般都会期望各个功能模块能够解耦合。通常情况下，会使用事件来达到这个效果。 第一次写这个类的话，很有可能就写成了这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import &#123;isFunction&#125; from './util';const EVENTS = Symbol('events');const STATE = Symbol('state');const STATE_READY = Symbol('stateReady');const STATE_DESTROIED = Symbol('stateDestroied');const CHECK_READY = Symbol('checkReady');export default class Event &#123; constructor() &#123; this[EVENTS] = &#123;&#125;; this[STATE] = STATE_READY; &#125; /** * 在调用on、trigger、safeTrigger、asyncTrigger、off的时候，要检查一下当前event对象的状态。 * * @private */ [CHECK_READY]() &#123; if (this[STATE] !== STATE_READY) &#123; throw new Error('wrong event state: the event object is not ready.'); &#125; &#125; /** * 绑定事件 * * @public * @param &#123;string&#125; eventName 事件名字 * @param &#123;Function&#125; fn 回调函数 * @param &#123;Object=&#125; context 上下文对象 */ on(eventName, fn, context) &#123; this[CHECK_READY](); if (!isFunction(fn)) &#123; return; &#125; let events = this[EVENTS]; events[eventName] = events[eventName] || []; events[eventName].push(&#123;fn, context&#125;); &#125; /** * 同步触发事件 * * @public * @param &#123;string&#125; eventName 事件名字 * @param &#123;...[*]&#125; args 要传给事件回调函数的参数列表 */ trigger(eventName, ...args) &#123; this[CHECK_READY](); let fnObjs = this[EVENTS][eventName]; for (let fnObj of fnObjs) &#123; fnObj.context::fnObj.fn(...args); &#125; &#125; /** * 移除事件回调 * * @public * @param &#123;...[*]&#125; args eventName，fn，context * @param &#123;string=&#125; args.0 参数名字 * @param &#123;function=&#125; args.1 回调函数 * @param &#123;Object=&#125; args.2 上下文对象 */ off(...args) &#123; this[CHECK_READY](); let [eventName, fn, context] = args; if (args.length === 0) &#123; this[EVENTS] = &#123;&#125;; &#125; let iterator = checkFn =&gt; &#123; let fnObjs = this[EVENTS][eventName]; let newFnObjs = []; for (let fnObj of fnObjs) &#123; if (checkFn(fnObj)) &#123; newFnObjs.push(fnObj); &#125; &#125; this[EVENTS][eventName] = newFnObjs; &#125;; if (args.length === 1) &#123; this[EVENTS][eventName] = null; &#125; else if (args.length === 2) &#123; iterator(fnObj =&gt; fn !== fnObj.fn); &#125; else if (args.length === 3) &#123; iterator(fnObj =&gt; fn !== fnObj.fn || context !== fnObj.context); &#125; &#125; destroy() &#123; this[EVENTS] = null; this[STATE] = STATE_DESTROIED; &#125;&#125; 在 trigger() 循环事件处理器的时候，事件回调函数很可能会通过 on() 间接修改 this[EVENTS] ，因此，我们需要使用 ProtectObject 来对 this[EVENTS] 进行锁定。 总结本质上，这类问题就是传入的函数中做了不希望做的事情，所以如何禁止或者兼容这些不希望做的事情是关键点。 本文为作者在实践中总结出来的方案，能力有限，期待读者提出更好的方案。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]},{"title":"WEB 中的文件下载","slug":"filedownload","date":"2016-06-17T00:59:00.000Z","updated":"2016-06-17T16:12:32.000Z","comments":true,"path":"blogs/filedownload.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/filedownload.html","excerpt":"在 WEB 开发中，我们会期望用户在点击某个链接的时候，下载一个文件（不管这个文件能不能被浏览器解析，都要下载）。以前接触过一种方式，就是在响应 header 中设置 force-download ： 12Content-Type: application/force-downloadContent-Disposition: attachment; filename=&quot;test.zip&quot; 然而，这是一种 hack 方式，并不推荐使用：","text":"在 WEB 开发中，我们会期望用户在点击某个链接的时候，下载一个文件（不管这个文件能不能被浏览器解析，都要下载）。以前接触过一种方式，就是在响应 header 中设置 force-download ： 12Content-Type: application/force-downloadContent-Disposition: attachment; filename=&quot;test.zip&quot; 然而，这是一种 hack 方式，并不推荐使用： Content-Type: application/force-download means “I, the web server, am going to lie to you (the browser) about what this file is so that you will not treat it as a PDF/Word Document/MP3/whatever and prompt the user to save the mysterious file to disk instead”. It is a dirty hack that breaks horribly when the client doesn’t do “save to disk”. QuentinUtility of HTTP header “Content-Type: application/force-download” for mobile? 有位小伙伴就遇到了不奏效的情况： ATTENTION:If you use any of the lines below your download will probably NOT WORK on Android 2.1. Content-Type: application/force-downloadContent-Disposition: attachment; filename=MyFileName.ZIPContent-Disposition: attachment; filename=”MyFileName.zip”Content-Disposition: attachment; filename=”MyFileName.ZIP”; Jörg WagnerAndroid and the HTTP download file headers 那么，究竟怎么办呢？接下来描述我的同事和我遇到的问题。 问题发现最近接手了一个新项目，今天刚好有空熟悉一下之前的功能。于是打开线上地址，输入测试账号，进入一个列表页面，这个列表页面提供了下载数据为 Excel 文件的功能，点了一下下载链接，猛然发现，下载的文件名字怎么是 download ？为啥呢？ 我用的浏览器是 Chrome 51 ，系统是 OS EI Capitan 10.11.5 。 我一同事 Chrome 47，可以完全正常下载！ 先看看为啥我的浏览器不行吧！ 第一步探索打开 Chrome 开发者工具，查看 HTTP 请求，发现响应头部有如下两项： 12Content-Type: application/octet-stream;charset=GBKContent-Disposition: attachment; filename=&quot;%D6%D0%CE%C4.xlsx 噢，filename 那里多了一个双引号，去掉吧！ 第二步探索然而，引号去掉之后，问题依旧！什么情况？难道是 filename 需要引号包起来？ 好吧，包起来试试！ 第三步探索包起来后问题依旧，什么鬼？ 灵机一动，去看看别人怎么做的吧！于是找到别人网站一个下载 Excel 的页面，点击下载，发现响应 header 里面是这样的： 12Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8Content-Disposition: inline;filename=&quot;%D6%D0%CE%C4.xlsx&quot;;filename*=utf-8&apos;&apos;%D6%D0%CE%C4.xlsx Content-Type 指明了具体的文件类型，然后 Content-Disposition 多了一个 filename*= ，这是什么东西？ utf-8 是什么编码？ 经过一堆胡乱搜索，猜测 utf-8 就是文件名的编码。为啥文件名要编码呢？呃，HTTP header 里面还未见过中文…… 好了，我们后端的代码大致做法是这样的： 12response.addHeader(\"Content-Type\", \"application/octet-stream\");response.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + new String(fileName.getBytes(\"GBK\"), \"ISO-8859-1\") + \"\\\".xlsx\"); 看起来，只需要用 filename*= 附上编码就行了，于是后端代码改成： 12response.addHeader(\"Content-Type\", \"application/octet-stream\");response.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + new String(fileName.getBytes(\"GBK\"), \"ISO-8859-1\") + \"\\\".xlsx;filename*=GBK''\" + new String(fileName.getBytes(\"GBK\"), \"ISO-8859-1\")); 好了，我再点击下载，没问题！ 第四步探索看起来好像是 OK 了，但是，用 IE 试一下，又不正常了，文件名字不对了！ 为什么呢？别人网站在 IE 下都能正常下载的！现在主要有两处区别： 我们的 Content-Type 没有写具体； 我们使用了 GBK 编码。 一思索，感觉编码的嫌疑较大，为啥呢？因为对于文件下载，浏览器根本不用管文件内容是个啥，只需要按照二进制流写入本地磁盘就好了，并且，此处也只是文件名错了，下载下来的文件内容还是没问题的。 那就改编码吧，改成 UTF-8 ： 12response.addHeader(\"Content-Type\", \"application/octet-stream\");response.addHeader(\"Content-Disposition\", \"attachment; filename=\\\"\" + new String(fileName.getBytes(\"UTF-8\"), \"ISO-8859-1\") + \"\\\".xlsx;filename*=UTF-8''\" + new String(fileName.getBytes(\"UTF-8\"), \"ISO-8859-1\")); 经测试，一切正常！ 总结在文件下载功能中，一般都会借助于这两个 header 来达到效果，那么两个 header 的具体作用是什么呢？ Content-Type：告诉浏览器当前的响应体是个什么类型的数据。当其为 application/octet-stream 的时候，就说明 body 里面是一堆不知道是啥的二进制数据。 Content-Disposition：用于向浏览器提供一些关于如何处理响应内容的额外的信息，同时也可以附带一些其它数据，比如在保存响应体到本地的时候应该使用什么样的文件名。 细想一下， Content-Type 好像对于文件下载没什么作用？事实上的确如此。可是再想一下，如果浏览器不理会 Content-Disposition ，不下载文件怎么办？如果此时提供了 Content-Type ,至少浏览器还有机会根据具体的 Content-Type 对响应体进行处理。 可是为什么浏览器会不理会 Content-Disposition 呢？因为这个 Content-Disposition 头部并不是 HTTP 标准中的内容，只是被浏览器广泛实现的一个 header 而已。 话题转一转， Content-Disposition 的语法见此处，其中相对重要的点此处罗列一下： 常用的 disponsition-type 有 inline 和 attachment ： inline：建议浏览器使用默认的行为处理响应体。 attachment：建议浏览器将响应体保存到本地，而不是正常处理响应体。 Content-Disposition 中可以传入 filename 参数，有两种形式： filename=yourfilename.suffix：直接指明文件名和后缀。 filename*=utf-8’’yourfilename.suffix：指定了文件名编码。其中，编码后面那对单引号中还可以填入内容，此处不赘述，可参考规范。 有些浏览器不认识 filename*=utf-8&#39;&#39;yourfilename.suffix （估计因为这东西比较复杂），所以最好带上 filename=yourfilename.suffix 。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/HTTP/"}],"keywords":[]},{"title":"使用 marked 解析 markdown 之缩进","slug":"使用 marked 解析 markdown 之缩进","date":"2016-06-15T08:12:00.000Z","updated":"2016-06-17T12:56:10.000Z","comments":true,"path":"blogs/使用 marked 解析 markdown 之缩进.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/使用 marked 解析 markdown 之缩进.html","excerpt":"在前面一篇文章使用 marked 解析 markdown中，大致介绍了一下 marked 使用过程中的一些问题，今天又再次遇到 ETPL 的 markdown 过滤器嵌套带来的问题。","text":"在前面一篇文章使用 marked 解析 markdown中，大致介绍了一下 marked 使用过程中的一些问题，今天又再次遇到 ETPL 的 markdown 过滤器嵌套带来的问题。 遇见问题这次，我想在 table 的 td 里面写 markdown ，期望效果看起来像是这样的： 而 markdown 代码，我是这样写的： 然后出来的效果是这样： 注意黑色的那段代码块，没缩进了！ 什么情况？为啥会没缩进呢？ 初步分析仔细一看 markdown 代码，发现里面出现了过滤器嵌套，也就是说，里面那块 markdown 代码会被处理两次！ 尝试解决方案1既然处理了两次，那么就得想办法只处理一次，于是将 markdown 代码改成这样： 看起来每个 markdown 块都只被处理了一次，应该可以了吧！ 于是，我得到了这个效果： 这个看起来好像没啥问题了。 但是，结合 filter 代码： 12345678var etpl = require('etpl');var marked = require('marked');etpl.addFilter('markdown', function (source, useExtra) &#123; source = source.replace(/(^\\n+|\\n+$)/g, ''); var uselessSpaceCount = source.match(/^\\s*/)[0].length; source = source.replace(new RegExp('^ &#123;' + uselessSpaceCount + '&#125;', 'gm'), ''); return marked(source);&#125;); 发现：第三个 &lt;!– filter: markdown() –&gt; 会导致自己的 markdown 块缩进出问题。 尝试解决方案2再来仔细玩味一下内嵌 filter 的处理流程吧，希望能找到解决方案。 经过各种 debug ，发现整个处理流程是这样的： 1、先处理最里面的 markdown 块（这是是 ETPL 的处理流程），然后生成对应的 HTML 代码，替换掉之前的 markdown 代码； 2、再处理外层的 markdown 块，这个块包含了第一步中生成的 HTML 代码块。于是在替换每行空格的时候，同样会替换掉第一步中生成的 code 标签中每一行前面相应的空格。 好了，现在为啥缩进会出问题的原因已经具体定位了，咋办呢？ 在第2步调用 marked 解析之前，完全可以把第一步中生成的 HTML 代码拿出来，这样第2步处理的时候就不会去掉 code 块中的有用空格了。这样一来，过滤器关键部分的代码就变成了： 12345678910111213141516171819var renderer = new marked.Renderer();require('etpl').addFilter('markdown', function (source, useExtra) &#123; // 把内嵌的 markdown 拿出来，防止多次转换 var nestMarkdowns = []; source = source.replace(/&lt;div class=\"markdown\"&gt;(.|\\n)*&lt;\\/div&gt;/g, function (match) &#123; nestMarkdowns.push(match); return '$&#123;nestMarkdown&#125;'; &#125;); source = source.replace(/^\\n+/, ''); var uselessSpaceCount = source.match(/^\\s*/)[0].length; source = source.replace(new RegExp('^ &#123;' + uselessSpaceCount + '&#125;', 'gm'), ''); return '&lt;div class=\"markdown\"&gt;' + marked(source, &#123;renderer: renderer&#125;) .replace(/\\$&#123;nestMarkdown&#125;/g, function () &#123; return nestMarkdowns.shift(); &#125;) + '&lt;/div&gt;';&#125;); 刷一下页面，再看，符合预期，完全正常！","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/markdown/"},{"name":"ETPL","slug":"ETPL","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ETPL/"}],"keywords":[]},{"title":"oracle 安装","slug":"oracle安装","date":"2016-05-23T04:13:00.000Z","updated":"2016-06-15T10:45:36.000Z","comments":true,"path":"blogs/oracle安装.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/oracle安装.html","excerpt":"这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。 本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。","text":"这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。 本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。 基本环境和工具 基于 Parallels Desktop 10 的 windows 10 操作系统； JDK 1.8； Oracle 11g。 其中， Oracle 11g 的下载地址是 win64_11gR2_database_1of2.zip 、 win64_11gR2_database_2of2.zip。 第一次安装第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 jdbc:oracle:thin:@10.211.55.4:1521:orcl （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。 后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。 如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑： client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！ 在 OS X 下面要手动配置各种环境变量。 第二次安装（卸载重装）某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。 网上搜了一些资料，没找到正确的处理方式，于是决定重装。 重装的第一步是卸载。 卸载很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。 于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。 后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 sc delete serviceName 命令删除服务。 这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用鼠标右键-&gt;删除的方式，结果发现被占用了，无法删除，此时可以到资源监视器 -&gt; cpu 标签 -&gt; 关联的句柄里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。 这样卸载完之后，就开始安装了。 重装按照第一次的安装流程来，一步一步的，比较顺利。 但是，在创建数据库的时候，老是说 local_listener=LISTENER_ORCL 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。 后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。 总结 这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。 相对于 MySQL ，Oracle 入门配置真特么麻烦。 做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。","categories":[],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/Oracle/"},{"name":"数据库","slug":"数据库","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/数据库/"}],"keywords":[]},{"title":"使用 marked 解析 markdown","slug":"使用marked解析markdown","date":"2016-05-20T05:49:00.000Z","updated":"2016-06-15T10:44:30.000Z","comments":true,"path":"blogs/使用marked解析markdown.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/使用marked解析markdown.html","excerpt":"marked 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。 最简单直接的一种使用方式： 123var marked = require('marked');console.log(marked('I am using __markdown__.'));// Outputs: &lt;p&gt;I am using &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt;","text":"marked 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。 最简单直接的一种使用方式： 123var marked = require('marked');console.log(marked('I am using __markdown__.'));// Outputs: &lt;p&gt;I am using &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt; marked 库主要提供了一个 marked 函数，该函数声明为： 1234567891011type OptionsType = &#123; highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=, renderer: marked.Renderer=, gfm: boolean=, tables: boolean=, breaks: boolean=, pedantic: boolean=, sanitize: boolean=, smartLists: boolean=&#125;;marked(markdownString: string, options: OptionsType=, callback: Function=): string; 其中，marked 可以通过 renderer 配置提供了自定义解析途径。 renderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法： code(string code, string language) blockquote(string quote) html(string html) heading(string text, number level) hr() list(string body, boolean ordered) listitem(string text) paragraph(string text) table(string header, string body) tablerow(string content) tablecell(string content, object flags) strong(string text) em(string text) codespan(string code) br() del(string text) link(string href, string title, string text) image(string href, string title, string text) 所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。 marked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。 以上就是 marked 最基本最核心的用法了。 其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。 markdown 缩进问题在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。 现在前端开发，经常会使用一些模板引擎，比如 ETPL ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器： 12345var etpl = require('etpl');var marked = require('marked');etpl.addFilter('markdown', function (source, useExtra) &#123; return marked(source);&#125;); 此时在对应的模板中，就可以使用该过滤器了： 1234567&lt;div&gt; &lt;!-- filter: markdown() --&gt; ### 标题 内容 &lt;!-- /filter --&gt;&lt;/div&gt; 此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。 为什么会这样呢？ 如果打印一下 markdown 过滤器处理函数中的 source 参数： 123456var etpl = require('etpl');var marked = require('marked');etpl.addFilter('markdown', function (source, useExtra) &#123; console.log(source); return marked(source);&#125;); 可以发现，打印出来的内容会是这个样子： 12345&quot; ### 标题 内容 &quot; 第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。 这明显跟 markdown 语法有冲突，必须要进行如下处理： 1、第一行和最后一行没啥实际内容，可以去掉； 2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 n ； 3、将每一行前面的 n 个空格去掉。 具体的代码实现如下： 12345678var etpl = require('etpl');var marked = require('marked');etpl.addFilter('markdown', function (source, useExtra) &#123; source = source.replace(/(^\\n+|\\n+$)/g, ''); var uselessSpaceCount = source.match(/^\\s*/)[0].length; source = source.replace(new RegExp('^ &#123;' + uselessSpaceCount + '&#125;', 'gm'), ''); return marked(source);&#125;); HTML 标签有的时候，可能想给 markdown 标记的某一块加上背景色，比如： 1234567&lt;!-- filter: markdown() --&gt;&lt;div class=\"background-red\"&gt;### 标题内容&lt;/div&gt;&lt;!-- /filter --&gt; 这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！ 解决方法就是把 div 放过滤器外边吧： 1234567&lt;div class=\"background-red\"&gt;&lt;!-- filter: markdown() --&gt;### 标题内容&lt;!-- /filter --&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/markdown/"},{"name":"ETPL","slug":"ETPL","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ETPL/"}],"keywords":[]},{"title":"实现第一个 vscode 扩展","slug":"实现第一个 vscode 扩展","date":"2016-01-10T10:20:00.000Z","updated":"2016-06-15T10:47:07.000Z","comments":true,"path":"blogs/实现第一个 vscode 扩展.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/实现第一个 vscode 扩展.html","excerpt":"提前声明：此处使用的 vscode 版本是0.10.6 vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。 个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。","text":"提前声明：此处使用的 vscode 版本是0.10.6 vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。 个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。 但是我个人很看重 vscode 的这些点： 1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ； 2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。 目前个人感觉的小缺点有： 1、无法代码折叠； 2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。 废话不对说，走一个插件先。 插件功能对 JavaScript 代码进行检查，基于的检查规则是 fecs 。 安装必要的东西 npm install -g yo generator-code 生成扩展项目执行下面的代码： yo code 然后会出现这样的选择界面： 选择： New Extension (JavaScript) 这样就会生成使用 JavaScript 进行插件开发的项目结构。 后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 npm install ，安装好 vscode 模块。 一切结束之后，你会发现在当前目录下生成了一个叫 test 的目录，进入这个目录，下面就有了一堆文件。 修改 package.json 文件更改 activationEvents 配置项，设为： 123[ \"onLanguage:javascript\"] 意思就是在打开 JavaScript 文件的时候会激活这个扩展。 删掉 contributes 配置项，此处用不上这个配置。 修改 extension.js 文件这个文件是 package.json 里面 main 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。 对于该扩展，其执行流程为： 1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法； 2、在用户保存文件的时候，执行 fecs 检查； 3、将第二步中检查出的错误和警告等信息显示到编辑器中。 开发过程在开发扩展的时候，要使用到 vscode 和 fecs 两个模块： 12var vscode = require('vscode');var fecs = require('fecs'); 然后注册文件保存的回调函数： 1234var disposable = vscode.workspace.onDidSaveTextDocument(function (event) &#123; // do something while saving&#125;);context.subscriptions.push(diagnosticCollection); 注意：此处 onDidSaveTextDocument 返回了一个 disposable 对象，这个对象有一个 dispose 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 context.subscriptions ，context 是 activate 方法调用的时候传入的上下文对象。 在这个回调函数里面就可以执行 fecs 检查了： 1234567891011fecs.check( &#123; type: 'js', name: 'FECS JS', _: [event.uri.path], stream: false &#125;, function (hasNoError, errors) &#123; // the result of check &#125;); hasNoError 和 errors 表明了检查结果。此处可以忽略 hasNoError ，直接将 errors 转换成 vscode 能够展示的错误。 vscode 提供了 DiagnosticCollection ，用于向界面上展示错误信息。那么如何操作呢？ 首先要拿到一个 DiagnosticCollection 对象： 1var diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs'); 然后往这个对象里面塞错误信息： 1diagnosticCollection.set(someErrorObject); 整合所有代码之后的样子整个 extension.js 的代码整合起来如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var path = require('path');var vscode = require('vscode');var fecs = require('fecs');fecs.leadName = 'fecs';exports.activate = function activate(context) &#123; var diagnosticCollection = vscode.languages.createDiagnosticCollection('fecs'); context.subscriptions.push(diagnosticCollection); vscode.workspace.onDidSaveTextDocument(function (event) &#123; diagnosticCollection.clear(); fecs.check( &#123; type: 'js', name: 'FECS JS', _: [event.uri.path], stream: false &#125;, function (hasNoError, errors) &#123; diagnosticCollection.set(convertErrors(errors)); &#125; ); &#125;);&#125;;function convertErrors(fecsErrors) &#123; return fecsErrors.map(function (error) &#123; return [ vscode.Uri.file(error.path), error.errors.map(function (fileError) &#123; // fecs的行号和列号与vscode有差异。。。。 var line = fileError.line - 1; var column = fileError.column - 1; return new vscode.Diagnostic( new vscode.Range(line, column, line, column + 1), `[FECS]: $&#123;fileError.message&#125; ($&#123;fileError.rule&#125;)`, &#123; 1: vscode.DiagnosticSeverity.Warning, 2: vscode.DiagnosticSeverity.Error &#125;[fileError.severity] ); &#125;) ]; &#125;);&#125; 注： fecs 是什么？","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/vscode/"}],"keywords":[]},{"title":"爬虫与编码","slug":"爬虫与编码","date":"2016-01-09T05:23:00.000Z","updated":"2016-06-08T09:52:21.000Z","comments":true,"path":"blogs/爬虫与编码.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/爬虫与编码.html","excerpt":"作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。","text":"作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。 其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。 于是，一些网站就会采取一些措施来阻止非正常访问： 某某关键接口只能每分钟调用若干次； 某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。 当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。 从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的： 如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理； 在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了； 对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。 等等，有点偏题了！下面进入正轨： 在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题： 面对这些乱码，如何解决呢？ 注意 HTTP 响应的头部留意一下 HTTP 响应的头部是否有用 gzip 压缩过： 1Content-Encoding:gzip 如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。 Node.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做： 12345678910111213141516// `res` 是响应对象，http.IncommingMessage 类型的var buffers = [];// 暂存 gzip 解压过后的 buffervar size = 0;// 记录整个响应体解压后的数据大小var gunzipStream = zlib.createGunzip();res.pipe(gunzipStream);gunzipStream.on('data', function (buffer) &#123; buffers.push(buffer); size += buffer.length;&#125;);gunzipStream.on('error', function (error) &#123; // 发生了错误，处理下吧！&#125;);gunzipStream.on('end', function () &#123; var unzipedBuffer = Buffer.concat(buffers, size); // unzipedBuffer 就是解压过后的数据&#125;); 注意文本编码拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？ Node.js 里面默认字符串是 utf-8 编码的，如果 gzip 解压出来的数据不是 utf-8 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。 怎么办呢？ 留意一下响应头当中的 Content-Type 部分，如果 charset 是非 utf-8 的话，那就要考虑继续对数据进行解码了。 对于中文网站，可能会使用 GBK 或者 GB2312 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 iconv-lite 。解码过程如下： 1var finallyResponseText = require('iconv-lite').decode(unzipedBuffer, 'gbk'); 这样，就拿到了最终想要的文本数据。","categories":[],"tags":[],"keywords":[]},{"title":"ES6 简单特性概览","slug":"ES6 简单特性概览","date":"2015-10-18T03:43:00.000Z","updated":"2016-07-01T03:56:27.000Z","comments":true,"path":"blogs/ES6 简单特性概览.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/ES6 简单特性概览.html","excerpt":"本文内容： 讲解了如何使用交互式的方式体验 ES6 。 列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。","text":"本文内容： 讲解了如何使用交互式的方式体验 ES6 。 列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。 体验 ECMAScript 6有三种简单的方式可以运行 ES6 代码： 1、 Web 浏览器：使用在线的 Babel REPL ，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。 2、命令行：使用 babel-node ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。 3、各种 JavaScript 引擎：查询 kangax 的 ES6 兼容表格，可以找到本地支持 ES6 的引擎。 下面将会给出更多关于选项1和2的内容。 Babel REPLBabel REPL 有四个主要部分： 左上角部分包含 ES6 源码。 左下角部分显示 ES6 代码中发现的语法错误。 右上角部分包含 ES6 代码编译成的 ES5 代码。 右下角部分展示通过 console.log() 输出的内容。 babel-nodebabel-node 可执行程序可以通过 npm 安装： 1npm install --global babel 你可以像使用可执行程序 node 一样使用 babel-node 。类似于 node ，像这样启动一个交互式的 REPL ： 1babel-node 一旦进入该 REPL ，你就可以执行 ES6 代码了： 123&gt; let arr = [1, 2, 3];&gt; arr.map(x =&gt; x * x)[ 1, 4, 9 ] 注意 babel-node 目前还不支持多行输入。 Babel 官网有更多关于 Babel 命令行工具的信息。 本文接下来的部分描述了易于接受的 ES6 特性。 从 var 到 let/constES6 有两种新的声明变量的方式： let （大致）相当于 var 的一个块级范围版本。 const 类似于 let ，但是用于创建常量：值不能被改变的变量。 一般情况下，你可以用 let 或者 const 替换每一个 var 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子： 123456789var x = 3;function func(randomize) &#123; if (randomize) &#123; var x = Math.random(); // (A) scope: whole function return x; &#125; return x; // accesses the x from line A&#125;func(false); // undefined func() 返回 undefined ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了： 12345678910var x = 3;function func(randomize) &#123; var x; if (randomize) &#123; x = Math.random(); return x; &#125; return x;&#125;func(false); // undefined 如果你在最初的版本中用 let 替换 var ，将会得到不一样的结果： 123456789let x = 3;function func(randomize) &#123; if (randomize) &#123; let x = Math.random(); return x; &#125; return x;&#125;func(false); // 3 因此，盲目地用 let 或者 const 替换 var 很危险。我的建议是： 仅在新的代码中使用 let/const 。 不动老的代码，或者小心地重构老的代码。 从 IIFE 到块级作用域在 ES5 中，你必须使用 IIFE 来使变量保持本地化： 123456(function () &#123; // open IIFE var tmp = ···; ···&#125;()); // close IIFEconsole.log(tmp); // ReferenceError 在 ECMAScript 6 中，你可以简单地使用一个块和一个 let 声明： 123456&#123; // open block let tmp = ···; ···&#125; // close blockconsole.log(tmp); // ReferenceError 从拼接字符串到模板字面量在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。 字符串插值在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中： 123function printCoord(x, y) &#123; console.log('('+x+', '+y+')');&#125; 在 ES6 中，你可以通过模板字面量的方式实现字符串插值： 123function printCoord(x, y) &#123; console.log(`($&#123;x&#125;, $&#123;y&#125;)`);&#125; 多行字符串模板字面量也可以用于表示多行字符串。 例如，下面是在 ES5 中表示多行文本的样子： 12345678910var HTML5_SKELETON = '&lt;!doctype html&gt;\\n' + '&lt;html&gt;\\n' + '&lt;head&gt;\\n' + ' &lt;meta charset=\"UTF-8\"&gt;\\n' + ' &lt;title&gt;&lt;/title&gt;\\n' + '&lt;/head&gt;\\n' + '&lt;body&gt;\\n' + '&lt;/body&gt;\\n' + '&lt;/html&gt;\\n'; 如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）： 12345678910var HTML5_SKELETON = '\\ &lt;!doctype html&gt;\\n\\ &lt;html&gt;\\n\\ &lt;head&gt;\\n\\ &lt;meta charset=\"UTF-8\"&gt;\\n\\ &lt;title&gt;&lt;/title&gt;\\n\\ &lt;/head&gt;\\n\\ &lt;body&gt;\\n\\ &lt;/body&gt;\\n\\ &lt;/html&gt;'; ES6 模板字面量可以跨越多行： 12345678910const HTML5_SKELETON = ` &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;`; （这些例子包含的空格数是不一样的，但是在此处并不重要。） 从函数表达式到箭头函数在当前的 ES5 代码中，在函数表达式中必须小心使用 this 。在下面的例子中，我创建了辅助变量 _this （行 A ），以便在行 B 能够访问到 UiComponent 的 this 。 1234567891011function UiComponent &#123; var _this = this; // (A) var button = document.getElementById('myButton'); button.addEventListener('click', function () &#123; console.log('CLICK'); _this.handleClick(); // (B) &#125;);&#125;UiComponent.prototype.handleClick = function () &#123; ···&#125;; 在 ES6 中，你可以使用箭头函数，它不会改变 this 指向（行 A ，词法范围的 this ）： 123456789101112class UiComponent &#123; constructor() &#123; let button = document.getElementById('myButton'); button.addEventListener('click', () =&gt; &#123; console.log('CLICK'); this.handleClick(); // (A) &#125;); &#125; handleClick() &#123; ··· &#125;&#125; 箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。 在 ES5 中，这样的回调函数相当啰嗦： 12var arr = [1, 2, 3];var squares = arr.map(function (x) &#123; return x * x &#125;); 在 ES6 中，箭头函数简洁很多： 12let arr = [1, 2, 3];let squares = arr.map(x =&gt; x * x); 在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： (x) =&gt; x * x 和 x =&gt; x * x 都是合法的。 处理多个返回值一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。 借助数组返回多个值exec() 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 matchObj ），即便是你仅对匹配组感兴趣： 123456var matchObj = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/ .exec('2999-12-31');var year = matchObj[1];var month = matchObj[2];var day = matchObj[3]; 在 ES6 中，解构使代码更简单： 123let [, year, month, day] = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/ .exec('2999-12-31'); 左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。 借助对象返回多个值方法 Object.getOwnPropertyDescriptor() 返回一个属性描述符，一个包含多个属性值的对象。 在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 propDesc ）： 1234567var obj = &#123; foo: 123 &#125;;var propDesc = Object.getOwnPropertyDescriptor(obj, 'foo');var writable = propDesc.writable;var configurable = propDesc.configurable;console.log(writable, configurable); // true true 在 ES6 中，可以使用解构： 123456let obj = &#123; foo: 123 &#125;;let &#123;writable, configurable&#125; = Object.getOwnPropertyDescriptor(obj, 'foo');console.log(writable, configurable); // true true {writable, configurable} 是下面内容的缩写： 1&#123; writable: writable, configurable: configurable &#125; 从 for 到 forEach() ，再到 for-of在 ES5 之前，可以选择使用数组方法 forEach() ： 123arr.forEach(function (elem) &#123; console.log(elem);&#125;); for 循环的优点在于可以中断， forEach() 的优点在于简洁。 在 ES6 中， for-of 循环结合了两种优点： 1234let arr = ['a', 'b', 'c'];for (let elem of arr) &#123; console.log(elem);&#125; 如果想访问每个元素的索引和值， for-of 也可以做到，通过新的数组方法 entries() 和解构： 123for (let [index, elem] of arr.entries()) &#123; console.log(index+'. '+elem);&#125; 处理参数默认值在 ES5 中，为参数指定默认值的代码像这样： 12345function foo(x, y) &#123; x = x || 0; y = y || 0; ···&#125; ES6 有更漂亮的语法： 123function foo(x=0, y=0) &#123; ···&#125; 一个额外的好处就是，在 ES6 中，参数默认值只会被 undefined 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。 处理命名参数在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的可选对象模式）： 1selectEntries(&#123; start: 0, end: -1 &#125;); 这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。 在 ES5 中，你可以这样实现 selectEntries() ： 123456function selectEntries(options) &#123; var start = options.start || 0; var end = options.end || -1; var step = options.step || 1; ···&#125; 在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了： 123function selectEntries(&#123; start=0, end=-1, step=1 &#125;) &#123; ···&#125; 可选参数在 ES5 中，要让参数 options 变得可选，会添加行 A 所示的代码： 1234567function selectEntries(options) &#123; options = options || &#123;&#125;; // (A) var start = options.start || 0; var end = options.end || -1; var step = options.step || 1; ···&#125; 在 ES6 中，可以用 {} 指定参数的默认值： 123function selectEntries(&#123; start=0, end=-1, step=1 &#125; = &#123;&#125;) &#123; ···&#125; 从 arguments 到剩余参数在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 arguments ： 12345function logAllArguments() &#123; for (var i=0; i &lt; arguments.length; i++) &#123; console.log(arguments[i]); &#125;&#125; 在 ES6 中，可以通过 ... 操作符声明一个剩余参数（下例中的 args ）： 12345function logAllArguments(...args) &#123; for (let arg of args) &#123; console.log(arg); &#125;&#125; 如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了： 123function format(pattern, ...args) &#123; ···&#125; 在 ES5 中处理这种场景很笨拙： 12345function format() &#123; var pattern = arguments[0]; var args = arguments.slice(1); ···&#125; 剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。 从 apply() 到扩展操作符（ … ）在 ES5 中，用 apply() 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。 4.11.1 Math.max()ES5 - apply() ： 12&gt; Math.max.apply(null, [-1, 5, 11, 3])11 ES6 - 扩展操作符： 12&gt; Math.max(...[-1, 5, 11, 3])11 Array.prototype.push()ES5 - apply() ： 12345var arr1 = ['a', 'b'];var arr2 = ['c', 'd'];arr1.push.apply(arr1, arr2); // arr1 is now ['a', 'b', 'c', 'd'] ES6 - 扩展操作符： let arr1 = [‘a’, ‘b’];let arr2 = [‘c’, ‘d’]; arr1.push(…arr2); // arr1 is now [‘a’, ‘b’, ‘c’, ‘d’] 从 concat() 到扩展操作符（ … ）扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 concat() 的功能。 ES5 - concat() ： 123456var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];console.log(arr1.concat(arr2, arr3)); // [ 'a', 'b', 'c', 'd', 'e' ] ES6 - 扩展操作符： 123456let arr1 = ['a', 'b'];let arr2 = ['c'];let arr3 = ['d', 'e'];console.log([...arr1, ...arr2, ...arr3]); // [ 'a', 'b', 'c', 'd', 'e' ] 从构造函数到类相对于构造函数来说，ES6 类是一种更加方便的语法。 基类在 ES5 中，直接实现构造函数： 123456function Person(name) &#123; this.name = name;&#125;Person.prototype.describe = function () &#123; return 'Person called '+this.name;&#125;; 在 ES6 中，类为构造函数提供了略微方便的语法： 12345678class Person &#123; constructor(name) &#123; this.name = name; &#125; describe() &#123; return 'Person called '+this.name; &#125;&#125; 继承类在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 Person 的子构造器 Employee 的方式： 12345678910function Employee(name, title) &#123; Person.call(this, name); // super(name) this.title = title;&#125;Employee.prototype = Object.create(Person.prototype);Employee.prototype.constructor = Employee;Employee.prototype.describe = function () &#123; return Person.prototype.describe.call(this) // super.describe() + ' (' + this.title + ')';&#125;; ES6 内置支持子类继承，使用 extends 子句： 123456789class Employee extends Person &#123; constructor(name, title) &#123; super(name); this.title = title; &#125; describe() &#123; return super.describe() + ' (' + this.title + ')'; &#125;&#125; 从自定义错误构造函数到 Error 子类在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪： 1234567function MyError() &#123; // Use Error as a function var superInstance = Error.apply(null, arguments); copyOwnPropertiesFrom(this, superInstance);&#125;MyError.prototype = Object.create(Error.prototype);MyError.prototype.constructor = MyError; 在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能： 12class MyError extends Error &#123;&#125; 从对象字面量中的函数表达式到方法定义在 JavaScript 中，方法就是值为函数的属性。 在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。 12345678var obj = &#123; foo: function () &#123; ··· &#125;, bar: function () &#123; this.foo(); &#125;, // trailing comma is legal in ES5&#125; ES6 有方法定义，一种创建方法的特殊语法： 12345678let obj = &#123; foo() &#123; ··· &#125;, bar() &#123; this.foo(); &#125;,&#125; 从对象到 Map把语言结构 object 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 __proto__ ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。 下面的 ES5 代码包含了函数 countWords ，该函数将对象 dict 用作一个 map ： 12345678910111213141516var dict = Object.create(null);function countWords(word) &#123; var escapedWord = escapeKey(word); if (escapedWord in dict) &#123; dict[escapedWord]++; &#125; else &#123; dict[escapedWord] = 1; &#125;&#125;function escapeKey(key) &#123; if (key.indexOf('__proto__') === 0) &#123; return key+'%'; &#125; else &#123; return key; &#125;&#125; 在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。 12345let map = new Map();function countWords(word) &#123; let count = map.get(word) || 0; map.set(word, count + 1);&#125; map 的另一个优点是可以用任何值作为键，而不仅仅是字符串。 从 CommonJS 模块到 ES6 模块直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如暴露的模块方式）。 ES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。 导出多个值在 CommonJS 里，像下面这样导出多个实体： 1234567891011121314151617181920//------ lib.js ------var sqrt = Math.sqrt;function square(x) &#123; return x * x;&#125;function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;module.exports = &#123; sqrt: sqrt, square: square, diag: diag,&#125;;//------ main1.js ------var square = require('lib').square;var diag = require('lib').diag;console.log(square(11)); // 121console.log(diag(4, 3)); // 5 相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 square 和 diag ： 1234//------ main2.js ------var lib = require('lib');console.log(lib.square(11)); // 121console.log(lib.diag(4, 3)); // 5 在 ES6 中，多个导出值被称为命名导出，像这样处理： 12345678910111213//------ lib.js ------export const sqrt = Math.sqrt;export function square(x) &#123; return x * x;&#125;export function diag(x, y) &#123; return sqrt(square(x) + square(y));&#125;//------ main1.js ------import &#123; square, diag &#125; from 'lib';console.log(square(11)); // 121console.log(diag(4, 3)); // 5 引入模块为对象的语法就像下面这样（行 A ）： 1234//------ main2.js ------import * as lib from 'lib'; // (A)console.log(lib.square(11)); // 121console.log(lib.diag(4, 3)); // 5 导出一个值Node.js 使用了 CommonJS 的模块方案，允许通过 module.exports 在模块中导出一个值： 123456//------ myFunc.js ------module.exports = function () &#123; ··· &#125;;//------ main1.js ------var myFunc = require('myFunc');myFunc(); 在 ES6 中， export default 完成同样的功能： 123456//------ myFunc.js ------export default function () &#123; ··· &#125; // no semicolon!//------ main1.js ------import myFunc from 'myFunc';myFunc();","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"}],"keywords":[]},{"title":"一个 JavaScript","slug":"一个 JavaScript","date":"2015-10-04T16:00:00.000Z","updated":"2016-06-15T10:46:43.000Z","comments":true,"path":"blogs/一个 JavaScript.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/一个 JavaScript.html","excerpt":"ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。 那么，什么是“版本化”？什么又是“一个 JavaScript”呢？","text":"ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。 那么，什么是“版本化”？什么又是“一个 JavaScript”呢？ 版本化一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。 如果代码库升级到新的语言版本，就有两种处理方式。 第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。 第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置： 1Content-Type: application/ecmascript;version=6 也可以利用 &lt;script&gt; 标签的 type 属性来标记： 123&lt;script type=\"application/ecmascript;version=6\"&gt; ···&lt;/script&gt; 也可以在代码内部标记版本（类似于 &#39;use strict&#39; ，放在 JavaScript 文件第一行）： 1use version 6; 这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。 一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题： 引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。 开发者需要记住版本之间的不同点。 代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。 因此，应该避免版本化，尤其是 JavaScript 和 web 。 一个 JavaScript既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？ 采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。 我们可以增加新的特性，使已有的特性更加强大。 这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“一个 JavaScript ”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。 “一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 let 就是这样干的，它用于声明块级变量，是 var 的改进版。但是它并没有替换掉 var ，只是作为更好的方案与 var 并存。 将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个： let 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的： 1let[x] = arr; 调查发现， web 上没人会在非严格模式下这样使用 let 变量，这就使得 TC39 能够将 let 引入非严格模式中。 严格模式和 ES6ECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式： 1'use strict'; 严格模式带来了三种具有破坏性的改变： 语法改变：一些之前合法的语法在严格模式下面是不允许的。例如： 禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。 删除一个独立的标识符（是一个变量，而不是一个属性）是不允许的。 函数只能在作用域的顶层声明。 更多的保留字： implements interface let package private protected public static yield 。 更多类型的错误。例如： 给一个未声明的变量赋值会抛出 ReferenceError 。而在非严格模式下，这样做就会创建一个全局变量。 修改只读的属性（比如字符串的长度属性）会抛出 TypeError 。而在非严格模式下，不会产生任何效果。 不同的语义：在严格模式下，一些结构体会表现得不一样。例如： arguments 不再随着当前参数值的改变而改变。 在非方法的函数中 this 为 undefined 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。 从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。 支持松散（非严格）模式一个 JavaScript 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。 但是很不幸，有两个特性很难引入松散模式： let 声明和块级函数声明。让我们看看为什么很难引入和如何引入。 松散模式中的 let 声明let 使你能够声明块级变量。这很难被引入到松散模式，因为 let 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的： 12var let = [];let[x] = 'abc'; 在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 let 作为变量名。然后第二行会被解析为一个 let 变量声明（使用解构）。 在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 let 声明。这种使用 let 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 let 声明的书写方式不会被误解： 12let foo = 123;let &#123;x,y&#125; = computeCoordinates(); 松散模式下的块级函数声明ECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。 ECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“ web 遗留的兼容语义”，允许块中的函数声明在函数作用域范围内存在。 其它关键字标识符 yield 和 static 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用： 在松散模式下， yield 仅在生成器函数中是保留字。 static 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。 隐式的严格模式在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 use strict 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。 其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。 无法修复的东西一个 JavaScript的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。 第一个， typeof null 应该返回字符串 null 而不是 object ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子： 12&gt; typeof Symbol.iterator&apos;symbol&apos; 第二个，全局对象（浏览器中的 window 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 let 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。 总结一个 JavaScript意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。 在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"}],"keywords":[]},{"title":"CSS 语法速查","slug":"CSS 语法速查","date":"2015-09-03T11:06:00.000Z","updated":"2016-06-15T10:45:09.000Z","comments":true,"path":"blogs/CSS 语法速查.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/CSS 语法速查.html","excerpt":"","text":"background123456[ &lt;bg-layer&gt; , ]* &lt;final-bg-layer&gt; &lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; &lt;final-bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; || &lt;&apos;background-color&apos;&gt; &lt;bg-image&gt; = &lt;image&gt; | none &lt;image&gt;&lt;position&gt;&lt;bg-size&gt;&lt;repeat-style&gt;&lt;attachment&gt;&lt;box&gt; radial-gradient()12345678&lt;radial-gradient&gt; = radial-gradient( [ [ &lt;shape&gt; || &lt;size&gt; ] [ at &lt;position&gt; ]? , | at &lt;position&gt;, ]? &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+) &lt;shape&gt; = circle || ellipse","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"CSS 空心字","slug":"CSS 空心字","date":"2015-09-01T16:00:00.000Z","updated":"2016-06-15T10:45:03.000Z","comments":true,"path":"blogs/CSS 空心字.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/CSS 空心字.html","excerpt":"空心字。","text":"空心字。 闪烁的空心字 带背景渐变的空心字 text-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"CSS 变形","slug":"CSS 变形","date":"2015-08-31T16:00:00.000Z","updated":"2016-06-15T10:44:56.000Z","comments":true,"path":"blogs/CSS 变形.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/CSS 变形.html","excerpt":"2D2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。","text":"2D2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。 skew() 函数示例： 下图描述了skew(30deg, 10deg)的工作原理： 注：上图来自 http://dtop.powereasy.net/Item/3715.aspx 。 transform-origintransform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。 但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如： 示例1和示例2中的虚线框是元素的原始位置，实线框是位移之后的位置。示例1的 transform-origin 是50% 50%，而示例2是100% 100%，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。 3D3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。 transform-styletransform-style 的取值为 flat 或者 preserve-3d 。下面的例子展示了两者的差别： 从示例中可以看出， preserve-3d 会让子元素在父元素变形的基础上继续变形，而 flat 则会消除父元素变形对子元素变形带来的影响。 理解： 对于第一种 div.container1 元素的 transform-style 为 flat 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 div.container1 元素的 transform-style 为 preserve-3d 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 div.container1 为基准的平面做变形。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"CSS border-radius","slug":"CSS border-radius","date":"2015-08-26T16:00:00.000Z","updated":"2016-06-15T10:44:50.000Z","comments":true,"path":"blogs/CSS border-radius.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/CSS border-radius.html","excerpt":"border-radius 的取值：","text":"border-radius 的取值： [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]? 上述示例的 CSS 代码为： border-radius 是可以通过/的形式来对某一个角设置一个椭圆弧的。 比如示例中的 20px/5px 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。 如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。 对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。 当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。 border-radius 可以做的效果：圆形、半圆、扇形、椭圆。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"CSS border-image","slug":"CSS border-image","date":"2015-08-26T16:00:00.000Z","updated":"2016-06-15T10:44:42.000Z","comments":true,"path":"blogs/CSS border-image.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/CSS border-image.html","excerpt":"上面示例的 css 代码为：","text":"上面示例的 css 代码为： 12345678.demo1 &#123; display: inline-block; width: 400px; height: 200px; border-width: 60px 70px; border-image: url(../images/8.jpg) 60 70 round stretch;&#125; CSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分： 1、图片来源。即示例中的 url(../images/8.jpg) ； 2、图片裁剪尺寸。即示例中的 60 70。裁剪尺寸遵循 top-right-bottom-left 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中60 70的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的； 3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。 -webkit-border-image 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"使用 CSS background 构造一个棋盘","slug":"使用 CSS background 构造一个棋盘","date":"2015-08-24T16:00:00.000Z","updated":"2016-06-15T10:46:57.000Z","comments":true,"path":"blogs/使用 CSS background 构造一个棋盘.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/使用 CSS background 构造一个棋盘.html","excerpt":"CSS background 的规范文档。","text":"CSS background 的规范文档。 使用的 CSS 代码如下： 12345678910111213div.demo1 &#123; width: 300px; height: 150px; background-color: #eee; background-image: linear-gradient(45deg, #bbb 25%, transparent 0), linear-gradient(45deg, transparent 75%, #bbb 0), linear-gradient(45deg, #bbb 25%, transparent 0), linear-gradient(45deg, transparent 75%, #bbb 0); background-size: 30px 30px; background-position: 0 0, 15px 15px, 15px 15px, 0 0;&#125; 整个 div 的背景色是 #eee 。 这个背景是由四幅代码“制造”的图片构成的，分别对应于四行 linear-gradient 。 第一幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。 第二幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。 第三幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-25%的颜色是 #bbb ，25%-100%的颜色是透明的（ transparent ），图片的大小是30px*30px的，图片从坐标(15px,15px)处开始绘制。 第四幅图片，颜色渐变，角度是 45deg ，于是从图片的左下角开始往右上角渐变。0-75%的颜色是透明的（ transparent ），75%-100%的颜色是 #bbb ，图片的大小是30px*30px的，图片从坐标(0,0)处开始绘制。 为了更清晰的看到每幅图片代码对应的区域，参考一下一段代码及其效果： 12345678910111213div.demo2 &#123; width: 300px; height: 150px; background-color: #eee; background-image: linear-gradient(45deg, red 25%, transparent 0), linear-gradient(45deg, transparent 75%, blue 0), linear-gradient(45deg, green 25%, transparent 0), linear-gradient(45deg, transparent 75%, orange 0); background-size: 30px 30px; background-position: 0 0, 15px 15px, 15px 15px, 0 0;&#125; 结语css 的 background 属性现在很强大了，利用背景“图片”的层叠，可以做出很多绚丽的背景效果。 更多 CSS background 的效果：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"}],"keywords":[]},{"title":"生成器（ generator ）","slug":"生成器（ generator ）","date":"2015-07-12T16:00:00.000Z","updated":"2016-06-15T10:47:30.000Z","comments":true,"path":"blogs/生成器（ generator ）.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/生成器（ generator ）.html","excerpt":"什么是 generator ？可以暂停（ pause ）和唤醒（ resume ）的函数。","text":"什么是 generator ？可以暂停（ pause ）和唤醒（ resume ）的函数。 实现一个迭代器1234567891011121314151617181920212223function* gen() &#123; for (let a of [1, 2, 3]) &#123; yield a + 1; &#125; return 5;&#125;// 下面的 for 循环输出：// 2// 3// 4for (let b of gen()) &#123; print(JSON.stringify(b));&#125;let it = gen();print(JSON.stringify(it.next())); // 输出： &#123;value: 2, done: false&#125;print(JSON.stringify(it.next())); // 输出： &#123;value: 3, done: false&#125;print(JSON.stringify(it.next())); // 输出： &#123;value: 4, done: false&#125;print(JSON.stringify(it.next())); // 输出： &#123;value: 5, done: true&#125;print(JSON.stringify([...gen()])); // 输出： [2, 3, 4] 创建 generator 的方式123456789101112131415161718192021222324// 第一种function* genFunc() &#123; ··· &#125;let genObj = genFunc();// 第二种const genFunc = function* () &#123; ··· &#125;;let genObj = genFunc();// 第三种let obj = &#123; * generatorMethod() &#123; ··· &#125;&#125;;let genObj = obj.generatorMethod();// 第四种class MyClass &#123; * generatorMethod() &#123; ··· &#125;&#125;let myInst = new MyClass();let genObj = myInst.generatorMethod(); generator 嵌套： yield*123456789101112131415161718192021222324252627function* gen1() &#123; yield 2; yield 3; return 'result of gen1';&#125;function* gen2() &#123; yield 1; // `yield* gen1()` 类似于 // for (let x of gen1()) &#123; // yield x; // &#125; print(JSON.stringify(yield* gen1())); yield 4;&#125;// 输出：// 'result of gen1'// [1, 2, 3, 4]print(JSON.stringify([...gen2()]));function* gen3() &#123; yield 1; yield* [2, 3]; yield 4;&#125;print(JSON.stringify([...gen3()])); // 输出： [1, 2, 3, 4] next 传值12345678910function* gen1() &#123; print(JSON.stringify(yield));&#125;let it = gen1();// 输出：// &#123;value: undefined, done: false&#125;// outer value// &#123;value: undefined, done: true&#125;print(JSON.stringify(it.next()));print(JSON.stringify(it.next('outer value'))); return() 外部终止 generator1234567891011121314function* gen1() &#123; print('a'); yield 1; print('b'); yield 2; print('c');&#125;// 输出：// a// &#123;value: 1, done: false&#125;// &#123;value: 'result', done: true&#125;let it = gen1();print(JSON.stringify(it.next()));print(JSON.stringify(it.return('result'))); throw() 抛出异常1234567891011121314151617function* gen() &#123; try &#123; print('Started'); yield; &#125; catch (error) &#123; print('Caught: ' + error.message); &#125; return 'return result';&#125;// 输出：// Started// &#123;value: undefined, done: false&#125;// Caught: error// &#123;value: 'return result', done: true&#125;let it = gen();print(JSON.stringify(it.next()));print(JSON.stringify(it.throw(new Error('error')))); 很有有趣也有用的例子123456789101112131415161718192021// for 循环延迟执行function* fn1(iterable) &#123; for (let x of iterable) &#123; if (x === 0) &#123; continue; &#125; yield x; &#125;&#125;function* fn2(iterable) &#123; for (let x of iterable) &#123; yield x + 1; &#125;&#125;function* fn3(iterable) &#123; for (let x of iterable) &#123; yield x / 2; &#125;&#125;let newArr = [...fn3(fn2(fn1([1, 2, 3])))];print(JSON.stringify(newArr)); // [1, 1.5, 2] generator 类图规范里面有一张很大的图，有点复杂。所以，看一张小图： 说明： 空心箭头表示两个对象的继承关系。换句话说，从 x 指向 y 的箭头意味着 Object.getPrototypeOf(x) === y 。 圆括号表示当前被包起来的对象是存在的，但是不能通过全局变量来访问。 带有 instanceof 字眼的箭头如果从 x 指向 y ，就表明 x instanceof y 。 o instanceof C 实际上就相当于 C.prototype.isPrototypeOf(o) 带有 prototype 字眼的箭头如果从 x 指向 y ，就表明 x.prototype === y 。 此图看完可能没有直观的感受，看两个例子先。 第一个， generator 函数表现得很像一个构造函数，因为通过 new 调用和直接调用，两者的效果是一样的，都返回 generator 对象，如下所示： 1234567&gt; function* g() &#123;&#125;&gt; g.prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;&gt; let obj = g();&gt; obj instanceof gtrue&gt; obj.hello()&apos;hi!&apos; 第二个，如果想给所有的 generator 对象添加一个方法，就可以放在 (Generator).prototype 上面，如下所示： 12345&gt; let Generator_prototype = Object.getPrototypeOf(function* () &#123;&#125;).prototype;&gt; Generator_prototype.hello = function () &#123; return &apos;hi!&apos;&#125;;&gt; let generatorObject = (function* () &#123;&#125;)();&gt; generatorObject.hello()&apos;hi!&apos; generator 内部的 this 是有一些猫腻的： 1234567891011121314151617function* gen1() &#123; 'use strict'; // just in case yield this;&#125;// Retrieve the yielded value via destructuringlet [functionThis] = gen1();console.log(functionThis); // undefinedlet obj = &#123; method: gen1 &#125;;let [methodThis] = obj.method();console.log(methodThis === obj); // truefunction* gen2() &#123; console.log(this); // ReferenceError&#125;new gen2(); 一个简单的类似于 tj co 库的东西1234567891011121314151617181920212223242526272829303132333435363738// 此段代码使用 node --harmony 执行executeGeneratorFn(function* () &#123; var result = yield request.bind(null, 'http://www.baidu.com', &#123;userId: 1&#125;); console.log(result);&#125;);executeGeneratorFn(function* () &#123; var userList = []; for (var param of [&#123;userId: 1&#125;, &#123;userId: 2&#125;]) &#123; userList.push(yield request.bind(null, 'http://www.baidu.com', param)); &#125; console.log(userList);&#125;);function request(url, params, callback) &#123; setTimeout(() =&gt; callback('request result: ' + Math.random()), 3000);&#125;function executeGeneratorFn(genFn, callback) &#123; var iterator = genFn(); next(); function next() &#123; try &#123; execute(iterator.next(arguments)); &#125; catch (e) &#123; callback instanceof Function &amp;&amp; callback(e); &#125; &#125; function execute(nextValue) &#123; if (!nextValue.done) &#123; nextValue.value(next); &#125; else &#123; callback instanceof Function &amp;&amp; callback(null, nextValue.value); &#125; &#125;&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"}],"keywords":[]},{"title":"百度（EFE）前端框架学习笔记（ef）","slug":"百度 EFE 前端框架学习笔记（ef）","date":"2015-05-31T16:00:00.000Z","updated":"2016-06-15T10:47:50.000Z","comments":true,"path":"blogs/百度 EFE 前端框架学习笔记（ef）.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/百度 EFE 前端框架学习笔记（ef）.html","excerpt":"官方 EF 学习资料：ActionPanel、UIModel、UIView。","text":"官方 EF 学习资料：ActionPanel、UIModel、UIView。 UIView.js与 ESUI 结合的 View 基类。该类有一个主入口方法 enterDocument()，该函数在容器渲染完毕后触发，用于控制元素可见性及绑定事件等 DOM 操作。 是 ESUI 中 View 类的子类。 该类对应的实例上会有一个视图上下文对象（ view.viewContext ），此上下文对象会传递给每个子控件，也就是说每个子控件都会有一个 viewContext 属性。此上下文对象的详细信息参看百度 EFE 前端框架学习笔记（esui）的 ViewContext.js 部分。 enterDocument() 方法会调用 ESUI 的 main.init() 方法，初始化当前 UIView 实例所管辖的 container 部分，生成各种各样的控件等等。 此类生成的实例上有一个很重要的事件属性 uiView.uiEvents，该属性有2种方式： 以 id:eventName 为键，以处理函数为值，比如 {&#39;someId:click&#39;: function() {/* do something */}}。 以 id 为键，值为一个对象，对象中以 eventName 为键，处理函数为值，比如 {someId: {eventName: function() {/* do something */}}}。 在此处声明的事件，运行时的 this 对象均是 View 实例，而非控件的实例。同时，在运行期，UIView 会克隆该属性，将其中所有的处理函数都进行一次 bind，将 this 指向自身，因此运行时的 uiEvents 与类声明时的不会相同。 此类上的 bindEvents() 方法就会根据 uiEvents 指定的事件配置来给子控件绑定事件。 UIModel.js处理 ESUI 场景的 Model 实现。 UIModel 继承自 er 的 Model。 UIModel 添加了 formatter 属性，用于对日期进行格式化。同时增加了一些操作数据的方法：set() 、 fill() 、 getPart()。 ActionPanel.js用于加载子Action的面板控件。继承自 esui 的 Panel 类，不过没有 setContent() 方法。 小技巧123456789function getControl(node) &#123; var controls = require('er/controller').currentAction.view.viewContext.getControls(); for (var k in controls) &#123; var control = controls[k]; if (control.main === node) &#123; return control; &#125; &#125;&#125; 该函数可以根据节点找到这个节点对应的控件对象，对debug有一定帮助。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]},{"title":"百度 EFE 前端框架学习笔记（esui）","slug":"百度 EFE 前端框架学习笔记（esui）","date":"2015-05-31T16:00:00.000Z","updated":"2016-06-15T10:48:04.000Z","comments":true,"path":"blogs/百度 EFE 前端框架学习笔记（esui）.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/百度 EFE 前端框架学习笔记（esui）.html","excerpt":"基础点： Control.js控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。 包含如下一些自有属性： type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等 skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更 styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替 id ： 控件的 id","text":"基础点： Control.js控件基类模块，该类不可以直接使用，经过继承之后，形成更加具体的按钮之类的控件才使用，可以认为就是一个控件抽象基类。 包含如下一些自有属性： type ：控件的类型，比如 Button 、 Input 、 Form 、 Calendar 等等 skin ：控件的皮肤，仅在初始化时设置有效，运行时不得变更 styleType ：控件的样式类型，用于生成各class使用，如无此属性，则使用 Control#type 属性代替 id ： 控件的 id 这些属性（ property ）均可在 html 代码中设置，比如： 1&lt;div data-ui-type=\"Button\"&gt;&lt;/div&gt; 还有另外一部分自有属性，这些属性不能用于 html 代码设置： helper ：控件常用的一些方法组成的一个对象属性 children ：子控件数组 childrenIndex currentStates domEvents main ： 控件的主元素， HTMLElement 类型 原型（ Control.prototype ）上面有一些对象属性： ignoreStates ： 指定在哪些状态下该元素不处理相关的DOM事件 控件的生命周期中，有如下状态： NEW ： 在进入构造函数后，控件的状态就是 NEW 了 INITED ： 控件完成 options 初始化（ initOptions() ）、视图环境初始化（ initViewContext() ）、扩展初始化（ initExtensions() ）之后状态就是 INITED 了 RENDERED ： 控件第一次调用 render() 方法之后，就转变为 RENDERED 了 DISPOSED ： 控件处于非 DISPOSED 状态下，调用 destroy() 方法，就变成了 DISPOSED 状态了 Control 上有一个重要的方法 render() ，用于渲染控件，该方法会去调用 repaint() 方法。 另外，Control 上还有一些 DOM 操作的方法，比如 appendTo() 、 insertBefore() 等。 Control 上的 get() 和 set() 很有猫腻。举个例子，如果这样调用 get() 方法： get(&#39;some-title&#39;) ，首先会去检测当前实例上面有没有 getSomeTitle() 方法，如果有，则直接调用这个方法，返回这个方法的返回值；如果没有，则直接返回当前对象的 some-title 属性。 set() 方法也是类似的。 setProperties() 方法可以用来批量设置属性，它会对一些特殊属性进行处理、控制，比如： 只有在渲染以前（就是 initOptions() 调用的那次）才允许设置 id 属性 如果要设置 viewContext ，则直接调用 setViewContext() 设置 有些属性要转换成布尔值，比如 disabled 、 hidden setProperties() 也会对批量设置的值进行脏检测，如果发现有属性值发生了改变，则会调用 repaint() 方法。脏检测函数是 isPropertyChanged() ， 默认只会用恒等号去判断是否变化，但是可以在子类中覆盖这个方法，实现自己想要的脏检测功能。 Button.js按钮控件。主要有这么几种按钮：普通按钮、添加按钮、下载按钮、链接按钮、右上角关闭按钮。 可以对按钮设置皮肤（ data-ui-skin ），内置的皮肤有： spring 、 spring-add 、 download 、 layerClose 、 link 。 可以禁用掉按钮（ data-ui-disabled=”diabled” ）。 按钮上 DOM 相关的事件只有 click 。由于按钮是间接继承自 EventTarget ，所以可以使用 on 、 un 等方法处理事件： 12345678910111213141516// 给按钮绑定事件处理函数someButton.on('click', handler);// 5s 后取消绑定事件绑定setTimeout(function () &#123; someButton.un('click', handler);&#125;, 5000);// 只执行一次的回调函数someButton.once('click', function () &#123; // only once&#125;);function handler(event) &#123; // do something&#125; 具体按钮 demo 可参看此处。 Validator数据验证模块，主要有三个基础类 Validity 、 ValidityState 、 Rule 。 ValidityState 表示某个控件的某一条验证规则的状态（是否验证通过），有两个自有属性： state ： 验证状态， true 为值合法， false 为值非法 message ： 验证信息，比如说错误提示语 Rule 是验证规则基类，是对 InputControl 的值的验证逻辑的抽象。每一个验证规则都包含一个 check(value, control) 方法，该方法返回一个 ValidityState 对象以表示验证结果。验证规则必须通过 main.registerRule() 进行注册后才可生效。每一个验证规则包含 prototype.type 属性来确定规则的类型。验证规则并不会显式地附加到控件上，而是通过控件自身的属性决定哪些规则生效，当控件本身具有与规则的type属性相同的属性时，此规则即会生效，例如： 12var textbox = main.create('TextBox', &#123; maxLength: 30 &#125;);textbox.validate(); 由于 textbox 上存在 maxLength 属性，因此 MaxLengthRule 会对其进行验证，此特性可以从 main.createRulesByControl() 方法中看出。 Validity 主要用于存放一系列验证结果（ ValidityState ），如果验证失败，则会触发 InputControl 的 invalid 事件，该事件会带上一个 Validity 对象作为参数。 InputControl.js输入控件基类模块，用于表示需要在表单中包含的控件，主要提供 getRawValue() 和 getValue() 方法供获取值。该类是一个抽象类，不应该直接使用。 需要注意的是，控件其实并不通过严格的继承关系来判断一个控件是否为输入控件，只要 getCategory() 返回为 &quot;input&quot; 、 &quot;check&quot; 或“extend”` 就认为是输入控件。 相比普通控件的 禁用 / 启用 ，输入控件共有3种状态： 普通状态：可编辑，值随表单提交 disabled ：禁用状态，此状态下控件不能编辑，同时值不随表单提交 readOnly ：只读状态，此状态下控件不能编辑，但其值会随表单提交 setValue() 和 getValue() 分别用于设置输入控件的值和获取输入控件的值。 getRawValue() 和 setRawValue() 用于处理控件原始值，原始值的格式由控件自身决定。这两对处理输入控件值的方法的主要区别是，setValue() 会先调用控件的 parseValue() （子类可重写此方法）方法转换传入的值，然后再调用 setRawValue() 设置到控件上面去， getValue() 也会调用控件的 stringifyValue() （子类可重写此方法）将 getRawValue() 得到的值转换后返回。 getValidationResult() 方法用于获取此控件数据验证结果。 BoxGroup.js选择框组控件的各种使用可参见此处。 CheckBox.jsCheckBox 控件在初始化时可以提供 datasource 属性，该属性用于控件判断一开始是否选中，且这个属性只在初始化时有效，不会保存下来。datasource可以是以下类型： 数组：此时只要rawValue在datasource中（使用==比较）则选上 其它：只要rawValue与此相等（使用==比较）则选上 示例。 ControlCollection.js控件集合，类似 jQuery 对象的功能，提供便携的方法来访问和修改一个或多个控件。 ControlCollection 提供 Control 的所有公有方法，但没有任何保护或私有方法。 对于方法， ControlCollection 采用 Write all, Read first 的策略，需要注意的是，类似 setProperties() 的方法虽然有返回值，但被归类于写操作，因此会对所有内部的控件生效，但只返回第一个控件执行的结果。 ControlCollection 仅继承 Control 的方法，并不包含任何子类独有方法，因此无法认为集合是一个 InputControl 而执行如下代码： 1collection.setValue('foo'); 此时可以使用通用的 set() 方法来代替： 1collection.set('value', 'foo'); 根据 set() 方法的规则，如果控件存在 setValue() 方法，则会进行调用。 ViewContext.js视图环境类，一个视图环境是一组控件的集合，不同视图环境中相同 id 的控件的 DOM id 不会重复。 该类的实例包含的主要属性为： controls ：该视图环境下所有的控件 groups ：视图环境控件分组集合 id ：视图环境 id，只读 当前页面所有的视图环境对象都会以id-&gt;对象的形式保存在私有的 pool 变量中。 painters.js渲染器模块，负责 dom 渲染。 可以生成各种各样的渲染器（ painter ）。例如： painters.state()：生成一个将属性与控件状态关联的渲染器 painters.attribute()：生成一个将控件属性与控件主元素元素的属性关联的渲染器 painters.style()：生成一个将控件属性与控件主元素元素的样式关联的渲染器 painters.html()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器 painters.text()：生成一个将控件属性与某个DOM元素的HTML内容关联的渲染器 painters.delegate()：生成一个将控件属性的变化代理到指定成员的指定方法上 借助于这些方法，可以为某一个控件生成一组渲染器，当该控件发生了变化（样式属性变化等），相应的渲染器就会被调用，从而保证了数据与界面的一致性，形成了单向数据流，同时也比较细腻度地更新指定界面部分，不会出现全局刷新的情况。 Extension.js扩展基类，针对控件的扩展。 Extension 类为扩展基类，所有扩展类需要继承于 Extension 。扩展类需要通过 main.registerExtension 方法，注册扩展类型。注册扩展类型时将自动根据 prototype.type 进行类型关联。 一个控件实例可以组合多个Extension实例，但一个控件实例对同种类型（即 type 相同）的 Extension ，只能拥有一份。 从设计上而言， Extension 不同于普通脚本对控件的操作，相比 ESUI 从设计理念上不希望普通脚本操作控件的保护属性及内部DOM元素，扩展则对控件拥有完全开放的权限，这包含但不限于： 注册事件、修改属性等其它逻辑程序可做的行为。 覆盖控件实例上的相应函数，如 render() 或 addChild() 等。 读取核心属性与关键属性，包括 type 、 main 等。 可接触控件内部的 DOM 对象，即可以访问 main 及其子树，并对 DOM 做任何操作。 在控件初始化时，会对扩展进行初始化，其基本流程为： 1、 当控件 init 之后，会依次对所有关联 Extension ，调用 attachTo() 方法。一个类型的 Extension 仅能在控件实例上附加一次，如果一个控件已经附加了同类型的 Extension 实例，则跳过本次 attachTo 操作。2、 当控件 dispose 之前，会依次对所有关联 Extension ，调用其 dispose() 方法。 有多种方法可以将扩展绑定到具体的控件实例上： 在控件创建时绑定 通过控件构造函数参数 options.extensions 可以为控件绑定扩展。 123456new TextBox(&#123; extensions: [ new MyExtension(&#123; ... &#125;), new OtherExtension(&#123; ... &#125;) ]&#125;); 在使用HTML生成时绑定 在HTML中，使用 data-ui-extension-xxx 属性注册一个扩展： 123456&lt;div id=\"main-panel\" class=\"wrapper\" data-ui-type=\"Panel\" data-ui-extension-command-type=\"Command\" data-ui-extension-command-events=\"click,keypress,keyup\" data-ui-extension-command-use-capture=\"false\"&lt;/div&gt; 在HTML中，使用 data-ui-extension-*-property 属性添加扩展，其中*作为扩展的分组，可以是任何字符串，相同的*将作为对同一扩展的定义，必须包含 data-ui-extension-*-type 定义扩展的类型，而其它 data-ui-extension-*-property=&quot;value&quot; 属性则将作为 options 参数的属性传递给扩展的构造函数。 在实例创建后动态地绑定 在控件创建后，可以动态创建扩展并在适当的时候绑定至控件。 1234567891011var panel = new Label(&#123; text: 'abc' &#125;);var delegateDOMEvents = main.createExtension( 'Command', &#123; eventTypes: ['click', 'keypress', 'keyup'], useCapture: false &#125;);// 需主动调用attachTo方法delegateDomEvents.attachTo(panel);panel.appendTo(container); 全局绑定 调用{@link main#attachExtension}函数可在全局注册一个扩展： 1main.attachExtension('Command', &#123; events: ['click'] &#125;); 全局注册的扩展，将会被附加到所有控件的实例上。使用 options 参数作为 Extension 创建时的选项，创建 Extension 实例时会对 options 做复制处理。 具体可以参考 extension.Command 作为示例，来学习扩展的编写。 src/main.js 中的 main.init() 方法该方法是整个 esui 的入口方法，可以指定当前要使用 esui 的 dom 节点容器，类似于 angular.bootstrap() 或者 React.render()，都是以指定的 dom 元素为根，然后开始渲染这块地盘。具体参数传递可参看文档。 该方法会返回一个这个块地盘初始化的控件对象集合，例如： 1234567&lt;div id=\"container\"&gt; &lt;button data-ui=\"type:Button;id:defaultBtn;\"&gt;默认按钮&lt;/button&gt; &lt;span data-ui=\"type:Button;id:springBtn;skin:spring\"&gt;创建&lt;/span&gt; &lt;div data-ui=\"type:Button;id:springAddBtn;skin:spring-add\"&gt;添加&lt;/div&gt; &lt;div data-ui=\"type:Button;id:downloadBtn;skin:download\"&gt;下载&lt;/div&gt; &lt;div data-ui=\"type:Button;id:actBtn;\"&gt;改变文字&lt;/div&gt;&lt;/div&gt; 此 container 初始化后就会返回五个控件对象控件的集合。 类关系 ControlCollection ControlGroup Extension EventTarget Control Button CommandMenu Crumb InputControl BoxGroup Calendar CheckBox RangeCalendar Region RichCalendar Schedule Select TextBox TextLine Dialog Label Frame Pager Panel Form Overlay SearchBox Sidebar Tab Table Tip TipLayer Toast Tree Validity Wizard Layer Link MonthView SafeWrapper TreeStrategy ViewContext 一些总结绝大多数控件在源码中其实都有比较详尽的说明了，只要仔细看看注释，再结合相关代码，很快就会用了。不过，在看代码的时候，以下几处务必留意： 1、 initOption() 函数，该函数会初始化一些参数，很多都可以通过 data-ui-xxx 来设置，也可以通过 set() 方法来设置； 2、 repaint 属性，该属性中存放了重绘相关的配置，留意会造成重绘的属性，这些属性往往也可以用上条所述方式设置； 3、留意控件会触发什么事件，直接在源代码中搜索 fire( ，即可快速知道该控件会触发什么事件。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]},{"title":"百度 EFE 前端框架学习笔记（er）","slug":"百度 EFE 前端框架学习笔记（er）","date":"2015-05-28T16:00:00.000Z","updated":"2016-06-15T10:47:57.000Z","comments":true,"path":"blogs/百度 EFE 前端框架学习笔记（er）.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/百度 EFE 前端框架学习笔记（er）.html","excerpt":"首先上一张图：","text":"首先上一张图： ajax.js此模块返回一个 ajax 对象，用于发送 ajax 请求，最主要的就是 request 方法。同时该对象上也会挂载 Ajax 构造函数。 返回的 ajax 对象上会带有一个钩子属性（ hooks ），钩子属性上包含的类容可能有： serializeData()： 将数据序列化为适合发送 http 请求的格式 serializeArray()：序列化一组数据，以便发送 http 请求 beforeExecute()：在请求发送之前调用 beforeCreate()：在创建 XMLHttpRequest 对象之前调用，如果该函数返回 true，则会返回一个假的 promise 对象 afterReceive()：在接受到响应的时候调用，此时，返回的数据都还未做解析处理 afterParse()：响应的数据已经经过解析处理了 beforeSend()：在 xhr 对象的 open() 调用之后，send 调用之前调用 request() 函数只有一个 options 对象参数，其属性如下： url：请求 url method：请求方法，POST 、 GET data：请求附带的数据对象 xhrFields：给 xhr 对象上混入的属性 dataType：返回的数据类型，比如，如果是 json 的话，则会对 xhr.responseText 做 JSON 解析 contentType：请求 MIME 类型，默认是 application/x-www-form-urlencoded，仅在 method 为非 GET 方式的时候有效 request() 函数的 options 参数上还可能混入其他一些参数，这些参数都是通过 xhr.config 来配置的，是 ajax 对象的全局配置，这些属性包括： cache：如果为 false，则会在请求的 url 后面加上时间戳参数 timeout：如果 timeout 大于0，则会有请求超时。如果发生了超时，则会触发 ajax 对象的 timeout 事件 charset：跟在 http contentType 后面的 charset，例如：application/x-www-form-urlencoded;charset=UTF-8 ajax 对象上除了 request 方法，还有如下一些方法： get()：发送 GET 请求的简短方法 getJSON()：用 GET 请求获取 JSON 数据 post()：发送 post 请求 log()：发送前端日志信息，不保证成功，没有回调 Action.jsAction 类，用于构造 action 对象。action 代表一种动作，比如页面跳转、鼠标事件、键盘事件等，都可以产生一个 action。 action 上会附着 model 和 view，进入 action 的时候，会先去加载 model 指定的数据，然后根据拿到的数据来渲染 view 指定的视图。 任何一个有 enter() 方法的对象都可作为 action 对象。 enter() 方法开启了 action 的生命周期，在 action 的生命周期中，会触发如下事件： enter：action 生命周期开始了 beforemodelload：action 上的 model（ action.model ） 加载之前触发 modelloaded：model 加载完成 beforerender：视图渲染之前 rendered：视图渲染完成 entercomplete：action 完成启动 beforeleave：离开 action 之前 leave：离开 action 之后，销毁注册在 action 上所有事件之前触发 action 生命周期相关的一些方法： enter()：action 入口函数 forwardToView()：转入 view 处理流程 leave()：离开 action，销毁 action 上的所有事件 reload()：重加载当前 action Model.jsMVC 中的 Model，主要用于从后端取数据，然后提供一些方法管理取到的数据。其中 load() 方法用于取数据，该方法会根据当前 model 对象上的数据源对象（ model.datasource ）去后端取数据。 数据源是对数据一系列配置，其中保存了多个数据的获取函数，有以下方式： 单一数据源配置 如果datasource是一个函数，则认为该函数是一个数据获取函数， 执行该函数，并把返回值按照一个对象放到当前 model 中 12// 配置从指定的URL获取数据datasource = require('./datasource').remote('/model/list') 并发请求数据 通过一个对象配置并发的数据获取。对象中每一个属性对应一个获取函数， 当数据获取后，会调用 this.set(name, result)，以属性名为键值添加 12345// 并发请求多个URLdatasource = &#123; 'list': require('./datasource').remote('/model/list'), 'config': require('./datasource').constant('listConfig')&#125;; 串行请求数据 通过一个数组配置并发的数据获取，数组中包含对象。将按照数组的顺序， 依次加载每一个对象（对象中的各属性是并发） 12345// 串行请求几个URLdatasource = [ &#123; 'config': require('./datasource').constant('config') &#125;, &#123; 'list': require('./datasource').remote('/model/list') &#125;]; 注意使用该方案时，各对象中的键不要相同 ，否则会造成数据的覆盖 嵌套配置 数组和对象可以相互嵌套，但有一个限制： 当一个对象中某个属性的值为普通对象（非数据加载配置项）或数组时，该属性名将不起作用，即不会在 model 对象中存在以该属性名为键的值。 以下为一个串行和并行混杂的数据源配置： 12345678datasource = &#123; 'one': [getX, getY, getZ], 'two': getA, 'three': [ &#123; 'four': getB &#125;, &#123; 'five': getC &#125; ]&#125;; 以上对象将在最终的 model 对象中生成 two 、 four 和 five 属性，而 one 、 two 和 three 因为属性值为普通对象或数组，将被忽略，其中one对应3个函数，将会把函数的返回值展开后添加到当前 model 同样，注意在嵌套的同时，各属性名不要相同，除非该属性名称没用，以避免出现数据相互覆盖的情况。 通过数据获取配置项 上面所述的各种方案，均是数据获取配置项的简写，一个数据获取配置项的结构请参考 meta/DatasourceOption.js。因此，可以使用数据获取配置项来处理一些例外情况，比如并行加载2个对象，且2个对象均无对应的键值，需要完整添加到 Model 对象： 1234567891011// 并行加载对象并完整添加到`Model`对象datasource = [ &#123; retrieve: require('./datasource').remote('/model/list'), dump: true &#125;, &#123; retrieve: require('./datasource').remote('/user/info'), dump: true &#125;]; 对于不同的简写，其与数据获取配置项的对应关系如下： 普通的函数，映射为 { retrieve: {fn}, dump: true } 对象中的一个属性，映射为 { retrieve: {fn}, name: {name} } View.js在 aciton 的生命周期中，加载完 model 数据之后，就会渲染视图了，此时调用的是 view.render() 方法，也就是说 view.render() 就是 view 的入口函数。er 的视图默认使用 etpl 模版引擎渲染。 在指定容器内渲染出 html 结构之后，就会调用 view.enterDocument() 方法，用于控制元素可见性及绑定事件等DOM操作。比如利用 esui 来初始化各种控件等等。 controller.js控制器类，负责 URL 与 Action 的调度，将 URL 映射到具体的一个 action 的执行上。 可以使用 controller.registerAction() 方法来注册 action 配置，配置数据放在 controller.actionPathMapping 属性上（ path 到配置对象的映射 ）。每一个配置对象包含以下属性（ actionConfig ）： path：该 action 对应的 url path type：如果是一个字符串，则认为是此 action 的模块路径，否则认为就是一个模块对象，直接使用 movedTo：如果此属性存在，则会定向到此属性指定的 URL，类似于302 childActionOnly：如果为 true，就说明这个配置仅用于子 action authority：权限配置，参考 meta.ActionConfig#authority 属性的说明 title： documentTitle 当路径改变时，会调用 controller.renderAction() 方法，此处渲染的是主 Action。渲染之前，会去 controller.actionPathMapping 上查找相应的 action 配置，如果找不到，则会跳转到404 url（404 url 可以通过 controller.setNotFoundLocation() 来设置）；如果没有找到404对应的 action 配置，则会 reject。判断完 action 配置是否存在之后，会检查是否有权限访问这个 url，如果没有权限，则会跳转到没有权限的页面（此页面可以通过 controller.setNoAuthorityLocation() 设置）。 在 action 的渲染过程中，会伴随一个 actionContext 对象，里面包含如下属性： url：此 action 对应的 url，是一个 URL 类的对象 container：容器元素的 id isChildAction：是否是子 action originalURL：之前的 url，在重定向、404、未授权的情况下，此属性会被设置，指代原始的那个 url title：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ） args：有 actionContext 对象的所有属性（除 args 属性之外） documentTitle：如果这个 action 是主 action，那么这个属性可以修改文档标题（ document.title ）。此属性比 title 属性优先级低 controller 对象有一个 eventBus 属性，该属性是 mini-event.EventBus 的实例。在此实例上，会有如下一系列事件触发： forwardaction：加载 action 之前 actionmoved：action 重定向，类似于302过程 actionnotfound：没有找到当前 url 对应的 action 配置 permissiondenied：没有权限访问当前的 url actionabort actionfail：当前 url 没有对应的 action 模块实现，或者创建 action 失败 actionloaded：action 加载完成 leaveaction：之前的主 action 销毁 enteraction：进入 action 之前触发 对于当前 url 加载到的 action 模块对象，如果是一个函数，则认为是一个 Action 构造函数，直接实例化；如果是一个包含 createRuntimeAction() 的对象，则认为这个 createRuntimeAction() 函数就是一个 Action 工厂函数，调用该工厂函数就可以创建出 action 对象；否则认为这个模块对象就是 action 实例。 找到了当前 url 对应的主 action 之后，就要开始进入这个 action 了。在进入之前，需要销毁之前的主 action（调用 action.leave() 方法）。销毁之后，调用 action.enter()，进入当前 action。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]},{"title":"Reflux 使用进化日记","slug":"Reflux 使用进化日记","date":"2015-05-21T16:00:00.000Z","updated":"2016-06-15T10:46:27.000Z","comments":true,"path":"blogs/Reflux 使用进化日记.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/Reflux 使用进化日记.html","excerpt":"Reflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）：","text":"Reflux 算是比较新的东西，由于自己水平有限，刚接触，不能很好地去使用 Reflux 来处理数据，下面是我使用 Reflux 逐步进化的过程（当然最终状态不一定就是标准的 Reflux 使用方式）： 第一步：初识 Reflux一直在听人说 Reflux ，说这个东西比较适合中小型的前端项目，使用起来很方便，于是我就找到了 Reflux 在 GitHub 的主页。 文档说 dispatcher 被移除了，没关系，反正我也没用过 Flux 。 于是继续阅读关于 actions 和 stores 的文档。由于心浮气躁急着用，看文档很马虎，action 、 store 可以监听过去监听过来的，还有 store 可以 connect 啥的，完全看晕了，无法用 Reflux 组织起一个完整的处理流程。但是没关系，我就按照文档上的这些 listen 啥的，自己来写写看吧。 于是， 创建 action ，在 store 中用 listenTo 来监听 action ，然后请求数据，store trigger 返回数据。写的时候，由于完全不理解 Reflux 怎么用，一通胡乱监听，写出来的代码不三不四，看着都觉得累。为了照顾项目进度，放弃 Reflux ，自己写一个 service 层吧。 第二步：认识了一点 Reflux过了几天，对 Reflux 心有不甘，于是转头再去看 Reflux 文档，同时也很开心找到一篇使用 Reflux 的经验文章，于是知道了 action 可以当成方法调用，在 action 中监听调用，发出请求之类的，然后 store 做一些存储等操作，再 trigger ，component 中通过 mixin 来监听 store 中的 trigger ，然后做一些界面变动，摘录一段那篇文章中的例子： 123456789101112131415161718192021222324252627var Reflux = require('reflux');var React = require('react');var UserAction = Reflux.createAction(&#123; 'login': &#123;children: ['success', 'failed']&#125;&#125;);UsersAction.login.listen(function(data) &#123; $.post('/api/users/Action/login', data).then(this.success, this.failed);&#125;);var UserStore = Reflux.createStore(&#123; listenables: UserAction, onLoginSuccess: function(payload) &#123; this.trigger(payload); &#125;, onLoginFailed: function(payload) &#123; this.trigger(payload); &#125;&#125;);var UserComponent = React.createClass(&#123; mixins: [Reflux.connect(UserStore, 'user')], render: function() &#123; return &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;; &#125;&#125;); 感觉自己似乎知道怎么来组织流程了，于是很开心地又去改造代码，希望能用上 Reflux 。 写了一会儿，发现完了，因为有这样的场景：就拿上述一小段代码来说，UserAction 中很可能还有其它 action ，例如： 1234var UserAction = Reflux.createActions(&#123; 'login': &#123;children: ['success', 'failed']&#125;, 'register': &#123;children: ['success', 'failed']&#125;&#125;); login 和 register 两个 action 都会触发 UserStore 中相应方法的调用，然后这些方法再调用 trigger ，然后改变 UserComponent 中 state.user 的值，此处有两个问题： 1、登录和注册最终得到的数据真的都要反映到 UserComponent 的 state.user 上吗？这样合适吗？ 2、如果登录报错了，怎么通知 UserComponent ，怎么告诉其错误信息？ 想了想，有种方案：组织好 trigger 返回的数据结构，比如像这样： 12345&#123; actionType: 'login', // 本次 action 的类型 status: 0, // 0代表出错了，1代表成功了 message: 'an error occurred' // 错误信息&#125; 但是转念一想，这明显不对，肯定不是标准的用法，这样的话我又得在 component 中写好多代码来分析这些分发复杂的情况，太不优雅了。 想了半天，实在没想出好的方式，在《聊一聊基于Flux的前端系统》中也没找到相关内容。 于是，使用 Reflux 的想法再次被搁置，继续使用 service 吧！ 第三步：别扭的方式解决出错处理改回 service 之后，心中还是蛮不爽的，便去一个牛人云集的 React 群(161461760)求助，初步描述完我的问题之后，群中一位热心网友提出了他的方式：给 store 添加方法，获取 action 执行的结果。 感觉这种方式似乎能解决问题，虽然还是有点别扭，于是代码变成了这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var Reflux = require('reflux');var React = require('react');var UserAction = Reflux.createActions(&#123; 'login': &#123;children: ['success', 'failed']&#125;&#125;);UsersAction.login.listen(function(data) &#123; $.post('/api/users/Action/login', data).then(this.success, this.failed);&#125;);var userStoreMixin = &#123; getLoginResult() &#123; if (this._error) &#123; throw this._error; &#125; return this._user; &#125;&#125;;var UserStore = Reflux.createStore(&#123; listenables: UserAction, mixins: [userStoreMixin], onLoginSuccess(payload) &#123; this._error = null; this.trigger(payload); &#125;, onLoginFailed(error) &#123; if (error.status === -1) &#123; this._error = new UnloginError(error.message); &#125; else &#123; this._error = new Error(error.message); &#125; this.trigger(); &#125;&#125;);var UserComponent = React.createClass(&#123; mixins: [Reflux.listenTo(UserStore, 'onUserStore')], onUserStore() &#123; try &#123; this.setState(&#123; user: UserStore.getLoginResult() &#125;); &#125; catch (e) &#123; if (e instanceof UnloginError) &#123; alert('not login'); &#125; else &#123; alert(e.message); &#125; &#125; &#125;, render() &#123; return &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;; &#125;&#125;); 似乎还行，于是开开心心地翻新项目代码，将 service 改成“这种的 Reflux ”。 第四步：产生新的想法按照第三步的思维使用了一段时间之后，感觉实在是别扭，越来越感受到这不是标准的方案，写出来的代码看着有点丑。 于是想啊想，突然，灵光一闪，还是应该回归到第二步中写的那个例子啊，store 应该只是用来处理正确的数据，至于那些报错什么的，可以用额外的 action 、 store 来处理啊！于是上述代码应该是这个样子的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var Reflux = require('reflux');var React = require('react');var UserAction = Reflux.createActions(&#123; 'login': &#123;children: ['success', 'failed']&#125;&#125;);UsersAction.login.listen(function(data) &#123; $.post('/api/users/Action/login', data).then(this.success, this.failed);&#125;);var ErrorAction = Reflux.createActions(&#123; Unlogin: &#123;&#125;, // 未登录 error: &#123;&#125; // 一般性的错误&#125;);var UserStore = Reflux.createStore(&#123; listenables: UserAction, onLoginSuccess(payload) &#123; this.trigger(payload); &#125;, onLoginFailed(payload) &#123; if (error.status === -1) &#123; ErrorAction.Unlogin(error.message); &#125; else &#123; ErrorAction.error(error.message); &#125; &#125;&#125;);var ErrorStoreMixin = &#123; UNLOGIN: 1, ERROR: 2&#125;;var ErrorStore = Reflux.createStore(&#123; listenables: ErrorAction, mixins: [ErrorStoreMixin], onUnlogin(message) &#123; this.trigger(&#123;type: this.UNLOGIN, message: message&#125;); &#125;, onError(message) &#123; this.trigger(&#123;type: this.ERROR, message: message&#125;); &#125;&#125;);var UserComponent = React.createClass(&#123; mixins: [Reflux.connect(UserStore, 'user'), Reflux.listenTo(ErrorStore, 'onErrorStore')], onErrorStore(error) &#123; if (error.type === ErrorStore.UNLOGIN) &#123; alert('not login'); &#125; else if (error.type === ErrorStore.ERROR) &#123; alert(error.message); &#125; &#125;, render() &#123; return &lt;span&gt;&#123;this.state.user.name&#125;&lt;/span&gt;; &#125;&#125;); 现在，感觉似乎完美一点了，代码看着也相对优雅。 不过，到目前为止，还有一点疑问：按照这种 store 写法，似乎会创建很多 store ，是否需要控制 store 数量，如果有必要，如何整合各个 store ？ 带着一些疑问，继续前行吧，骚年！ （后续有使用心得的时候会继续更新本文章）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"},{"name":"Reflux","slug":"Reflux","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/Reflux/"},{"name":"React","slug":"React","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/React/"}],"keywords":[]},{"title":"记一次坑爹的对接经历","slug":"记一次坑爹的对接经历","date":"2015-05-06T16:00:00.000Z","updated":"2016-06-15T10:48:12.000Z","comments":true,"path":"blogs/记一次坑爹的对接经历.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/记一次坑爹的对接经历.html","excerpt":"事情是这样的： 后端提供了一个数据接口 /account/my/address/ 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。","text":"事情是这样的： 后端提供了一个数据接口 /account/my/address/ 。咱是有追求的程序员，自然接口要采用 RESTful 的思想，于是服务器端非成功的处理，都会返回 http code 非200的状态码，坑由此而生。 在前端请求这个地方，由于做的是移动端应用，果断采用了手写 xhr 请求，大致接口请求代码如下： 1234567891011121314151617181920212223function encodeParams(params) &#123; var paramsStr = []; for (var k in params) &#123; paramsStr.push(k + '=' + params[k]); &#125; return paramsStr.join('&amp;');&#125;function post(url, params) &#123; return new Promise(function(resolve, reject) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', url); xhr.onload = function() &#123; resolve(xhr.response); &#125;; xhr.onerror = function() &#123; reject(xhr.response); &#125;; xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send(encodeParams(params)); &#125;);&#125;post('/account/my/address/', &#123;/*参数*/&#125;) .then(function(response) &#123; // some code &#125;); 代码写好，拿到 chrome 中一测，出现一个似乎像是请求没发出去的错误： 对于当时不知道 chrome://net-internals/ 这个强大工具的我来说，这种错误简直就是一个莫名其妙的东西，很难搞。 于是仔细看一眼 request header ，发现没有 Content-Length ！这是怎么回事？为什么浏览器没计算出来 Content-Length ？很不可思议！ 于是，尝试改变一下请求 body 的编码方式，将上述 post 函数改成这样： 123456789101112131415161718function createFormData(params) &#123; var fd = new FormData(); for (var k in params) &#123; fd.append(k, params[k]); &#125; return fd;&#125;function post(url, params) &#123; return new Promise(function(resolve, reject) &#123; var xhr = new XMLHttpRequest(); xhr.open('POST', url); xhr.onload = function() &#123; resolve(xhr.response); &#125;; xhr.onerror = function() &#123; reject(xhr.response); &#125;; xhr.setRequestHeader('Content-Type', 'multipart/form-data'); xhr.send(createFormData(params)); &#125;);&#125; 再测，出现这样的错： 仍然没有 Content-Length ，错误依旧，简直令人发指！ 于是重新审视当前的开发模式，整个结构是这样的：我在本地开发前端静态部分，需要数据的时候通过 xhr 请求到后端去请求，为了避免我本地开发的时候还要启动一个后端服务器程序，于是让后端的同学将后端代码部署在一个公网的服务器上，这样我就可以通过代理或者 CORS 的方式来请求相应的接口了。 所以此时此刻，有点怀疑是不是这种模式引发的问题，但是再一想，其它很多获取数据提交数据都是这种模式啊，为啥就正常呢！所以这种怀疑被打消。 chrome 的开发者工具提供的信息太有限，实在想不出来是什么问题，于是到 QQ 群求助网友，其中一位网页给出了这个： chrome://net-internals/ ，抱着试一试的心态，打开，观察，哇咔咔，好牛逼，请求的各个过程尽收眼底！其中我找到了我的 POST 请求： 嗯，看来请求还是被正常发送出去了的。再往下看，发现了这个： ERR_UNEXPECTED_PROXY_AUTH 映入眼帘，代理需要认证？啥玩意儿？然后再看到一个 Server: nginx/1.4.6 (Ubuntu) ，仔细想想，为毛 nginx 会说代理认证错误！抓狂，去找后端人员，后端人员果断说不可能是 nginx 有问题！ 于是，再次崩溃， google 吧！于是尝试各种关键字搜索： ERR_UNEXPECTED_PROXY_AUTH 、 net_error = -323 … 搜索的时候，出现了一条关于 http code 407 的记录，点进去一看，惊呆了， 407 的含义如下： Proxy Authentication Required 需要代理授权！再看看上面的那张图，后端返回的 http code 果然是407，于是找到后端人员，问他可能会返回407吗？答案是 yes ！（我“怒发冲冠”，于是后端同学，卒） 总结这次问题解决总结下来有这么几个点，以后要注意： 1、在 RESTful 开发中，一定要对状态码足够敏感； 2、好好使用 chrome://net-internals/ ，确实挺强大； 3、chrome 出现上述类似错误的时候（407、请求未成功发送出去等等），很可能不显示完整的请求头，不显示响应信息（因为按照语义，此时根本无响应信息可显示）。","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/HTTP/"}],"keywords":[]},{"title":"一些 core javascript 的基础知识","slug":"一些 core javascript 的基础知识","date":"2014-10-22T14:13:00.000Z","updated":"2016-06-15T10:46:51.000Z","comments":true,"path":"blogs/一些 core javascript 的基础知识.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/一些 core javascript 的基础知识.html","excerpt":"一、 setTimeout1234setTimtout(function()&#123; alert(2); // 后弹出&#125;,0);alert(1); // 先弹出 对于如上代码，包含原理如下： 1、首先 jsvm 只会执行一个线程； 2、当这个线程遇到 setTimout() 的时候，就会将这个 function 放到某个队列里面； 3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。","text":"一、 setTimeout1234setTimtout(function()&#123; alert(2); // 后弹出&#125;,0);alert(1); // 先弹出 对于如上代码，包含原理如下： 1、首先 jsvm 只会执行一个线程； 2、当这个线程遇到 setTimout() 的时候，就会将这个 function 放到某个队列里面； 3、当前这个线程空闲的时候，就会执行任务队列轮询的代码，将满足条件的函数拿出来执行。 比较简单典型的一个应用场景就是： 12345$(elem).html(xxxxxx);setTimeout(function() &#123; // 内部DOM操作很复杂，此处setTimeout用于保证在内部DOM操作结束并且相关内存被释放掉后执行后续代码&#125;, 0); 二、 evaljs 中除了全局作用域和函数作用域之外，还存在一个 eval 作用域。 eval 函数执行的时候，会根据当前执行上下文创建一个作用域。 此处有如下代码： 123456function a() &#123; var b = new SomeThing(); return function() &#123; eval(''); &#125;;&#125; 三、预编译先分别上如下几个片段的代码： 1234567891011&lt;html&gt;&lt;head&gt;&lt;script&gt;a();function a()&#123; alert(1);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314&lt;html&gt;&lt;head&gt;&lt;script&gt;a();&lt;/script&gt;&lt;script&gt;function a()&#123; alert(1);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011&lt;html&gt;&lt;head&gt;&lt;script&gt;a();var b = function a()&#123; alert(1);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 执行结果分别是： 第一段代码：弹出1； 第二段代码：第一个script片段报错，a不存在； 第三段代码：报错，a不存在； 原因： 第一段代码中，jsvm会预编译，构造好a函数，所以访问a函数的顺序是不重要的； 第二段代码中，预编译是会分代码块执行的，每个script都会形成一个代码块，即便script是通过src引入js的； 第三段代码中，a函数的定义由于放在了一个表达式当中，因此jsvm不会预编译。 但是，此处还可以继续深入，第三段代码改成如下所示： 1234567891011&lt;html&gt;&lt;head&gt;&lt;script&gt;var b = function a()&#123; alert(1);&#125;a();&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这段代码也同样会报错， a 不存在。为什么呢？原因就是 a 函数放在了表达式当中， jsvm 会把 a 函数看作一个匿名函数，因此在当前语句执行完， a 就被释放掉了。 但是，请注意，上面讨论的都是根据 w3c 标准得出的结果，在第三段和第四段代码中，IE 6、7、8还是会预编译的，并且不会释放掉a，因此不会报错。 四、自执行函数自执行函数的几种形式： 1234(function() &#123;&#125;)();(function() &#123;&#125;());!function()&#123;&#125;();void function()&#123;&#125;(); 其中第三种写法会造成额外的运算，因为要对返回的内容做“非”操作。 五、预编译中的变量声明如下代码： 12345function a(x)&#123; return x*2;&#125;var a;alert(a); var a 只是声明，并不会干啥， var a 只会让当前作用域的 alert(a) 不会报 a 不存在的错误， a 实际上是什么，需要显示赋值；如果 var a 之前已经存在 a 了，则啥也不干。 六、 function 传参如下代码： 123456789101112131415function fn1(a, b, c)&#123; a = 1.2; b = 2.2; c.c = 3.2;&#125;var a = 1;var b = 2;var c = &#123;c:3&#125;;fn1(a,b,c);alert(a);alert(b);alert(c.c); 原理不难理解，注意值类型和引用类型的区别。 七、作用域链有如下几点： 1、作用域链是在定义的时候就确定下来了的； 2、隐式对象模型：对于一个作用域， jsvm 会创建一个隐式对象，然后在这个对象上面绑定当前作用域的各种变量。多个函数的嵌套定义也就会形成一条作用域链了。如果在某个作用域中要访问一个 a 变量，则会首先在当前作用域中查找是否存在 a 变量，如果不存在，则向上找父作用域隐式对象中是否存在 a 变量，依次类推，如果到了根作用域还找不到 a 变量的话，就会报错了。 八、类数组结构第一个问题，如何构造类数组结构？思路简单，不赘述。 jquery 选择器构造出来的就是一个类数组结构。 九、工厂模式123function factory() &#123; return new ThisIsAClass();&#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]},{"title":"web 前端外部点击事件的实现","slug":"web 前端外部点击事件的实现","date":"2014-10-22T06:52:00.000Z","updated":"2016-06-15T10:46:16.000Z","comments":true,"path":"blogs/web 前端外部点击事件的实现.html","link":"","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/blogs/site/blogs/web 前端外部点击事件的实现.html","excerpt":"在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。","text":"在 web 前端开发中，元素外部点击事件算是非常常用的一种事件了。比如弹出一个对话框，点击对话框外部的时候需要把这个对话框关掉。 实现这个事件有一个核心的东西，就是判断两个节点是否存在父子关系，整个事件流程如下： 1、事先设定好的一组元素，如果在这组元素外部点击的话，就会触发外部点击事件，这组元素暂记为 nodes ； 2、用户点击一个元素，可以从 event.target 中获取到当前用户点击的节点，暂记为 nodeClick ； 3、当用户点击 nodeClick 的时候，需要判断 nodes 中是否存在 nodeClick 的祖先节点，如果不存在的话，则触发外部点击事件。 按照这个分析，关键点就落在了判断节点父子关系上面了。 其实早在 IE5 的时候，元素节点上面就有一个方法 contains() ，用于判断父子关系，具体文档可参见： https://developer.mozilla.org/en-US/docs/Web/API/Node.contains 。从文档中，我们可以看见 mobile 部分测试不太充分，所以此处最好保留一个自己实现的版本，代码如下： 123456789101112131415function contains(parentNode, childNode) &#123; var fn = Node.prototype.contains || function(childNode) &#123; while (childNode) &#123; if (childNode === parentNode) return true; childNode = childNode.parentNode; &#125; &#125;; return fn.call(parentNode, childNode);&#125;function isIn(parentNodes, node) &#123; for (var i = 0, il = parentNodes.length; i &lt; il; i += 1) &#123; if (contains(parentNodes[i], node)) return true; &#125; return false;&#125; 实现了这个之后，接下来的事情就是维护回调函数队列了，实现机制可能会有多种，此处给出其中一种。 给出一个Array，用于记录所有回调函数，其中每一个数组元素的结构如下： 1234&#123; nodes: [node1, node2, ...], // 对应上一大步中的nodes变量，即事先设定好的那一组元素 callback: function() &#123;&#125; // 触发本次out click事件的回调函数&#125; 暂记这个 Array 变量的名字是 outerCallbacks 。 接下来，就剩下对外提供 API 了，此处向外部提供两个 API ： 1、 on() 函数，用于注册回调函数； 2、 off() 函数，用于取消回调函数。 on函数的实现非常简单，此处直接上代码： 12345678function outer(elem, callback) &#123; if (!isFunction(callback)) return; // isFunction = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Function]';&#125; outerCallbacks.push(&#123; nodes: (isArray(elem) ? elem : [elem]), // isArray = function(obj) &#123;return Object.prototype.toString.call(obj) === '[object Array]'&#125; callback: callback &#125;);&#125; 实现 off() 函数的时候，有一个难点和一个注意点： 难点：参数处理，条件判断； 注意点：在外部点击事件回调函数里面调用了 off() 函数怎么办？ 可以参看我的实现： https://github.com/yibuyisheng/web-ui/blob/master/static/js/event/outer.js 。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"}],"keywords":[]}]}