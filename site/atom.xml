<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yibuyisheng</title>
  <subtitle>偶尔玩玩 Java 的前端工程师</subtitle>
  <link href="/blogs/site/atom.xml" rel="self"/>
  
  <link href="http://yibuyisheng.github.io/blogs/site/index.html/"/>
  <updated>2017-01-06T10:05:40.000Z</updated>
  <id>http://yibuyisheng.github.io/blogs/site/index.html/</id>
  
  <author>
    <name>yibuyisheng</name>
    <email>yibuyisheng@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6 中的模式匹配和默认参数</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/ES6%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/ES6 模式匹配和默认参数.html</id>
    <published>2017-01-05T16:00:00.000Z</published>
    <updated>2017-01-06T10:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 中，引入了其他很多语言都具备的<code>模式匹配</code>和<code>默认参数</code>语法糖，使得代码简洁了不少。但是使用的时候还是有些细节需要注意。<br><a id="more"></a></p>
<h2 id="模式匹配原理"><a href="#模式匹配原理" class="headerlink" title="模式匹配原理"></a>模式匹配原理</h2><h3 id="模式匹配的种类"><a href="#模式匹配的种类" class="headerlink" title="模式匹配的种类"></a>模式匹配的种类</h3><p>具体来说，有三种类型的模式匹配：</p>
<ul>
<li><p>直接赋值</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>对象模式</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;name, <span class="attr">age</span>: age&#125; = &#123;<span class="attr">name</span>: <span class="string">'yibuyisheng'</span>, <span class="attr">age</span>: <span class="number">25</span>&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>数组模式</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>];</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="模式匹配的过程"><a href="#模式匹配的过程" class="headerlink" title="模式匹配的过程"></a>模式匹配的过程</h3><ul>
<li><p>直接赋值：x ← value（包括 <code>undefined</code> 和 <code>null</code>）</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = value</div></pre></td></tr></table></figure>
</li>
<li><p>对象模式</p>
<p>  该种模式下，会检查匹配源是不是对象，如果不是对象，则会使用内部的 <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject" target="_blank" rel="external">ToObject()</a> 进行转换。</p>
<ul>
<li><p>{«properties»} ← undefined</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</div></pre></td></tr></table></figure>
</li>
<li><p>{«properties»} ← null</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</div></pre></td></tr></table></figure>
</li>
<li><p>{key: «pattern», «properties»} ← obj</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">«pattern» ← obj.key</div><div class="line">&#123;«properties»&#125; ← obj</div></pre></td></tr></table></figure>
</li>
<li><p>{key: «pattern» = default_value, «properties»} ← obj</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let tmp = obj.key;</div><div class="line">if (tmp !== undefined) &#123;</div><div class="line">  «pattern» ← tmp</div><div class="line">&#125; else &#123;</div><div class="line">  «pattern» ← default_value</div><div class="line">&#125;</div><div class="line">&#123;«properties»&#125; ← obj</div></pre></td></tr></table></figure>
</li>
<li><p>{} ← obj</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// No properties left, nothing to do</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数组模式</p>
<p>  该种模式下，右侧必须是可迭代的，如果不可迭代，就会抛出错误。</p>
<ul>
<li><p>[«elements»] ← non_iterable</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">assert(!isIterable(non_iterable))</div><div class="line">throw new TypeError();</div></pre></td></tr></table></figure>
</li>
<li><p>[«elements»] ← iterable</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">assert(isIterable(iterable))</div><div class="line">let iterator = iterable[Symbol.iterator]();</div><div class="line">«elements» ← iterator</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="模式匹配中需要注意的"><a href="#模式匹配中需要注意的" class="headerlink" title="模式匹配中需要注意的"></a>模式匹配中需要注意的</h2><h3 id="undefined-触发默认值"><a href="#undefined-触发默认值" class="headerlink" title="undefined 触发默认值"></a>undefined 触发默认值</h3><p>如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]; <span class="comment">// x = 1</span></div></pre></td></tr></table></figure>
<p>右侧的 <code>underfined</code> 元素会触发左侧的默认值。</p>
<h3 id="在需要的时候才会去计算默认值"><a href="#在需要的时候才会去计算默认值" class="headerlink" title="在需要的时候才会去计算默认值"></a>在需要的时候才会去计算默认值</h3><p>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">prop</span>: y = someFunc()&#125; = someValue;</div></pre></td></tr></table></figure>
<p>只有在右侧 <code>someValue.prop</code> 为 <code>undefined</code> 的时候才会执行 <code>someFunc()</code> 函数。</p>
<h3 id="模式匹配中可以引用模式中前面的变量"><a href="#模式匹配中可以引用模式中前面的变量" class="headerlink" title="模式匹配中可以引用模式中前面的变量"></a>模式匹配中可以引用模式中前面的变量</h3><p>比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">3</span>, y = x] = [<span class="number">7</span>, <span class="number">2</span>]; <span class="comment">// x=7; y=2</span></div></pre></td></tr></table></figure>
<p>这个地方要注意顺序，比如下面这个就是错误的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">3</span>] = [<span class="number">7</span>, <span class="number">2</span>]; <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
<h2 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h2><p>函数传参的过程，实际上就包含了模式匹配的过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function func(«FORMAL_PARAMETERS») &#123;</div><div class="line">    «CODE»</div><div class="line">&#125;</div><div class="line">func(«ACTUAL_PARAMETERS»);</div><div class="line"></div><div class="line">// 大致是：</div><div class="line"></div><div class="line">&#123;</div><div class="line">    let [«FORMAL_PARAMETERS»] = [«ACTUAL_PARAMETERS»];</div><div class="line">    &#123;</div><div class="line">        «CODE»</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="函数默认参数，慎用对象引用"><a href="#函数默认参数，慎用对象引用" class="headerlink" title="函数默认参数，慎用对象引用"></a>函数默认参数，慎用对象引用</h2><p>有如下示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list = [];</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a = list</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line"></div><div class="line">fn(); <span class="comment">// console.log: []</span></div><div class="line">list.push(<span class="number">1</span>);</div><div class="line">fn(); <span class="comment">// console.log: [1]</span></div></pre></td></tr></table></figure>
<p>默认参数使用了 list 引用，那么后续对 list 的修改，都会体现到默认参数上面去。在大型项目开发中，容易失控。如果一定要用某个变量生成默认值，建议深拷贝一份：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list = [];</div><div class="line"><span class="keyword">const</span> listDefaultParam = deepClone(list); <span class="comment">// 其它地方不要再使用这个变量了，并且在函数内部也不要修改这个变量值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a = listDefaultParam</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="默认参数的作用域"><a href="#默认参数的作用域" class="headerlink" title="默认参数的作用域"></a>默认参数的作用域</h2><p>使用最新版的 Chrome 浏览器执行下面的代码，注意输出结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">(&#123;</div><div class="line">    method() &#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">a = (</span>) =&gt; <span class="title">console</span>.<span class="title">log</span>(<span class="params">this</span>)) </span>&#123;</div><div class="line">            a();</div><div class="line">        &#125;</div><div class="line">        innerFn.call(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).method();</div><div class="line"></div><div class="line">(&#123;</div><div class="line">    method() &#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">a = (</span>) =&gt; <span class="title">console</span>.<span class="title">log</span>(<span class="params">this</span>)) </span>&#123;</div><div class="line">            a();</div><div class="line">        &#125;</div><div class="line">        innerFn();</div><div class="line">    &#125;</div><div class="line">&#125;).method();</div><div class="line"></div><div class="line">(&#123;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">let</span> arrowFn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">a = arrowFn</span>) </span>&#123;</div><div class="line">            a();</div><div class="line">        &#125;</div><div class="line">        innerFn();</div><div class="line">    &#125;</div><div class="line">&#125;).method();</div><div class="line"></div><div class="line">(&#123;</div><div class="line">    method() &#123;</div><div class="line">        <span class="keyword">let</span> arrowFn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params">a = arrowFn</span>) </span>&#123;</div><div class="line">            a();</div><div class="line">        &#125;</div><div class="line">        innerFn.call(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;).method();</div><div class="line"></div><div class="line"><span class="comment">// output:</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Object(&#123;method: ()&#125;)</span></div><div class="line"><span class="comment">// Window &#123; ... &#125;</span></div><div class="line"><span class="comment">// Object(&#123;method: ()&#125;)</span></div><div class="line"><span class="comment">// Object(&#123;method: ()&#125;)</span></div></pre></td></tr></table></figure>
<p>实际上，将上述代码用 babel 转换一下，可以发现默认参数的处理过程发生在函数开始部分。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 中，引入了其他很多语言都具备的&lt;code&gt;模式匹配&lt;/code&gt;和&lt;code&gt;默认参数&lt;/code&gt;语法糖，使得代码简洁了不少。但是使用的时候还是有些细节需要注意。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
      <category term="ECMAScript 6" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"/>
    
  </entry>
  
  <entry>
    <title>当心，babel 处理 Symbol 的麻烦</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E5%BD%93%E5%BF%83%EF%BC%8Cbabel%20%E5%A4%84%E7%90%86%20Symbol%20%E7%9A%84%E9%BA%BB%E7%83%A6.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/当心，babel 处理 Symbol 的麻烦.html</id>
    <published>2016-12-28T14:29:00.000Z</published>
    <updated>2016-12-28T15:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。<br><a id="more"></a></p>
<p>有的团队为了避免引入这个额外的 polyfill ，会选择不使用 Symbol ，包括通过 babel 生成 Symbol 的特性（比如 <code>for of</code> 等）。</p>
<p>这时候就会有个比较隐蔽的地方需要注意，就是尽量不要让 babel 生成这样的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</div></pre></td></tr></table></figure>
<p>这个里面包含了一个 <code>Symbol</code> ，为了让 <code>Symbol</code> 不至于报错，又要想办法在全局先声明一下 <code>Symbol</code> 变量，比较丑陋。</p>
<p>目前在实践中，发现这样的 ES next 代码会生成上述代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">        filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(a);</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成的代码为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _typeof = <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span>.iterator === <span class="string">"symbol"</span> ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj; &#125; : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Symbol</span> === <span class="string">"function"</span> &amp;&amp; obj.constructor === <span class="built_in">Symbol</span> &amp;&amp; obj !== <span class="built_in">Symbol</span>.prototype ? <span class="string">"symbol"</span> : <span class="keyword">typeof</span> obj; &#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">var</span> _ret = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">            filter(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(a);</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">v</span>: <span class="keyword">void</span> <span class="number">0</span></div><div class="line">            &#125;;</div><div class="line">        &#125;();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((<span class="keyword">typeof</span> _ret === <span class="string">"undefined"</span> ? <span class="string">"undefined"</span> : _typeof(_ret)) === <span class="string">"object"</span>) <span class="keyword">return</span> _ret.v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码有什么特征呢？就是在 <code>if</code> 块中定义了函数，函数中访问了 <code>if</code> 块中的“块级变量”，并且 <code>if</code> 块使用了 <code>return</code> 语句。</p>
<p>可以看出，babel 为了保证 <code>if</code> 块内变量的作用域，会套一个匿名函数，同时由于 <code>if</code> 块中存在 <code>return</code> 返回，所以就用 <code>_ret</code> 来接收匿名函数的返回值。然后后面为啥会生成那串长长的对 <code>_ret</code> 的类型判断代码，目前还不太清楚，可能要结合 babel 的内部处理逻辑去看了，单从生成的代码看，这个完全是多余的。</p>
<p>推而广之， <code>for</code> 块等局部非函数作用域都会有类似的问题。</p>
<p>实际上，从代码编写规范角度来看，是不应该在这种局部作用域块里面定义函数的。函数应该是一段通用的代码，不应该缩在那一小块里面。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用 babel 转换 ES next 代码的时候，并不会将 Symbol 直接转换成 ES5 中对应的内容，需要引入额外的 polyfill 才能正常工作。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
      <category term="babel" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/babel/"/>
    
  </entry>
  
  <entry>
    <title>Redux 使用初探</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/Redux%20%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/Redux 使用初探.html</id>
    <published>2016-12-25T16:00:00.000Z</published>
    <updated>2016-12-26T11:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 提供的主要功能：全局数据管理，包括数据的更新、存储、数据变化通知。 Redux 的 store 中存放了当前应用的状态，可以根据这个状态完整恢复出当前应用的界面，因此在使用 Redux 的项目中，可以实现一个比较炫酷的功能：依据状态的前进、后退。<br><a id="more"></a></p>
<p>Redux 中主要有三大块：</p>
<ul>
<li>Action：指代引起 Redux 中数据变化的操作；</li>
<li>Reducer：响应 Action 操作，修改 Redux 中的数据；</li>
<li>Store：包含一个 state 对象，用于存放整个应用的数据，并整合将 Action 和 Reducer 整合起来，修改 Store 中的数据。</li>
</ul>
<p>目前，网上已经有很多中文资料介绍具体概念细节以及相关 API 了，比如：</p>
<ul>
<li><a href="http://cn.redux.js.org/" target="_blank" rel="external">Redux 中文文档</a></li>
<li><a href="http://www.alloyteam.com/2015/09/react-redux/" target="_blank" rel="external">React 数据流管理架构之 Redux 介绍</a></li>
</ul>
<p>这里主要想记录一下作为一个初学 Redux 的菜鸟，使用过程中的心得体会。</p>
<p>单单就 Redux 本身来看，并不能直接用于生产，太灵活了，有很多“套路”需要强制定下来：</p>
<ul>
<li>怎么设计 state 对象的数据结构？怎么分好模块？怎么规定各个模块的命名风格？</li>
<li>Redux 只提供了注册 state 变化回调函数的 API ，如果只想监听其中某一个数据的变化该怎么办？</li>
<li>如果在 state change 的回调函数中再次 dispatch Action ，就可能造成无限递归，怎么设计才能很好地避免这种无限递归？</li>
<li>如何设计组织项目代码才更好维护？</li>
<li>如何避免写大量重复的 Action 、 Reducer 代码？</li>
</ul>
<h1 id="划分代码目录"><a href="#划分代码目录" class="headerlink" title="划分代码目录"></a>划分代码目录</h1><p>目录的划分方式有多种，可以按照项目的功能模块，也可以按照 Redux 的职责模块。我选择了后者，采用的目录结构如下：</p>
<p><img src="../images/2016-12-26/directory.png" alt=""></p>
<p>外部可以直接引入的 JS 模块只能是 <code>data/main</code> 和 <code>data/actionTypes</code> 。</p>
<h1 id="解决递归调用"><a href="#解决递归调用" class="headerlink" title="解决递归调用"></a>解决递归调用</h1><p>为什么会有递归调用呢？参考如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'SOME_THING_LOAD_COMPLETE'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">            <span class="attr">loadComplete</span>: <span class="literal">true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> store = createStore(reducer);</div><div class="line"></div><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">// do something here.</span></div><div class="line"></div><div class="line">    store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'SOME_THING_LOAD_COMPLETE'</span>&#125;);</div><div class="line">);</div><div class="line"></div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'SOME_THING_LOAD_COMPLETE'</span>&#125;);</div></pre></td></tr></table></figure>
<p>上面这个简单的例子很清晰地说明了无限递归的问题，在实际开发中，由于业务逻辑的复杂纠缠，这个递归过程可能非常间接、隐蔽，造成 debug 困难。那么如何有效避免呢？</p>
<p>一个比较常用的方法就是检查对应数据是否真的发生了变化，比如上面的代码可以改为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</div><div class="line">  <span class="keyword">switch</span> (action.type) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="string">'SOME_THING_LOAD_COMPLETE'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</div><div class="line">            <span class="attr">loadComplete</span>: <span class="literal">true</span></div><div class="line">        &#125;);</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> state;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> store = createStore(reducer);</div><div class="line"></div><div class="line"><span class="keyword">let</span> previousLoadComplete;</div><div class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">// do something here.</span></div><div class="line"></div><div class="line">    <span class="keyword">let</span> currentLoadComplete = store.getState().loadComplete;</div><div class="line">    <span class="keyword">if</span> (currentLoadComplete !== previousLoadComplete) &#123;</div><div class="line">        store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'SOME_THING_LOAD_COMPLETE'</span>&#125;);</div><div class="line">        previousLoadComplete = currentLoadComplete;</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">store.dispatch(&#123;<span class="attr">type</span>: <span class="string">'SOME_THING_LOAD_COMPLETE'</span>&#125;);</div></pre></td></tr></table></figure>
<p>由于 state 每次更新都会在相应位置产生一个新对象，所以只需要用全等来判断就行了。</p>
<h1 id="组织-state-数据结构"><a href="#组织-state-数据结构" class="headerlink" title="组织 state 数据结构"></a>组织 state 数据结构</h1><p>如何划分 state 对象的结构呢？可能每个人根据自己的经验，都有自己的一套划分方式。此处我采用了与业务功能模块对齐的原则。</p>
<p>比如，我的项目里面有这样一些页面：用户列表页面、用户详情页面、资源页面、资源详情页面，那么 state 对象的结构为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">state = &#123;</div><div class="line">    <span class="string">'user.list'</span>: &#123; ... &#125;,</div><div class="line">    <span class="string">'user.detail'</span>: &#123; ... &#125;,</div><div class="line">    <span class="string">'resource.list'</span>: &#123; ... &#125;,</div><div class="line">    <span class="string">'resource.detail'</span>: &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结构扁平化了。</p>
<p>个人建议，不要使用“多层”的 state 结构，比如把上面的例子设计成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BAD</span></div><div class="line">state = &#123;</div><div class="line">    <span class="attr">user</span>: &#123;</div><div class="line">        <span class="attr">list</span>: &#123; ... &#125;,</div><div class="line">        <span class="attr">detail</span>: &#123; ... &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">resource</span>: &#123;</div><div class="line">        <span class="attr">list</span>: &#123; ... &#125;,</div><div class="line">        <span class="attr">detail</span>: &#123; ... &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>过深的结构会带来不必要的复杂度。</p>
<h1 id="扩展事件监听方式"><a href="#扩展事件监听方式" class="headerlink" title="扩展事件监听方式"></a>扩展事件监听方式</h1><p>Redux 只提供了 <code>subscribe</code> 方法来监听 state 的变化，在实际开发中，某一个组件可能只对某部分 state 变化感兴趣。所以，应当适当地做一下扩展：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">StateWatcher</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 存放监听回调函数等</div><div class="line">     *</div><div class="line">     * @private</div><div class="line">     * @type &#123;Array.&lt;Object&gt;&#125;</div><div class="line">     */</div><div class="line">    watcherList = [];</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数</div><div class="line">     *</div><div class="line">     * @constructor</div><div class="line">     * @param &#123;store&#125; Store  Redux store实例</div><div class="line">     */</div><div class="line">    <span class="keyword">constructor</span>(store) &#123;</div><div class="line">        <span class="keyword">this</span>.store = store;</div><div class="line">        <span class="comment">// 存放之前 state</span></div><div class="line">        <span class="keyword">this</span>.previousStoreState = extend(&#123;&#125;, <span class="keyword">this</span>.store.getState());</div><div class="line">        <span class="keyword">this</span>.subscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 订阅 store 中 state 变化事件，会去检查 watcherList 中是否存在相应数据变化的回调函数</div><div class="line">     *</div><div class="line">     * @private</div><div class="line">     */</div><div class="line">    subscribe() &#123;</div><div class="line">        <span class="keyword">let</span> me = <span class="keyword">this</span>;</div><div class="line">        <span class="keyword">this</span>.unsubscribe = <span class="keyword">this</span>.store.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> currentStoreState = me.store.getState();</div><div class="line">            <span class="keyword">let</span> changedPropertyNameList = [];</div><div class="line">            <span class="keyword">let</span> delayFns = [];</div><div class="line"></div><div class="line">            <span class="comment">// 遍历 watcherList ，查找注册的回调函数</span></div><div class="line">            each(me.watcherList, watcher =&gt; &#123;</div><div class="line">                <span class="keyword">let</span> propertyName = watcher.propertyName;</div><div class="line">                <span class="keyword">let</span> previous = me.previousStoreState[propertyName];</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (currentStoreState[propertyName] !== previous) &#123;</div><div class="line">                    changedPropertyNameList.push(propertyName);</div><div class="line">                    <span class="comment">// 这里 context 对应的是某个组件，如果组件销毁了，就没有必要调用相应回调函数了。</span></div><div class="line">                    <span class="keyword">if</span> (!watcher.context.isInStage(componentState.DESTROIED)) &#123;</div><div class="line">                        <span class="comment">// 回调函数得延迟执行，因为回调函数是不可控的，在回调函数中可能又 dispatch 另外的 action ，</span></div><div class="line">                        <span class="comment">// 那就相当于此次 action 还没处理完，新的又来了，容易造成莫名其妙的错误。</span></div><div class="line">                        <span class="comment">// 所以要秉承处理完当前 action 的前提下，才能处理下个 action 的原则。</span></div><div class="line">                        delayFns.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                            watcher.watcherFn.call(</div><div class="line">                                watcher.context,</div><div class="line">                                propertyName,</div><div class="line">                                currentStoreState[propertyName],</div><div class="line">                                previous</div><div class="line">                            );</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="comment">// 统一更新属性</span></div><div class="line">            each(changedPropertyNameList, propertyName =&gt; &#123;</div><div class="line">                me.previousStoreState[propertyName] = currentStoreState[propertyName];</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="comment">// action 处理完之后，统一调用延迟函数。</span></div><div class="line">            each(delayFns, fn =&gt; fn());</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加属性变化的回调函数</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param &#123;string&#125; propertyName 属性名</div><div class="line">     * @param &#123;Function&#125; watcherFn 回调函数</div><div class="line">     * @param &#123;Component&#125; context 组件</div><div class="line">     */</div><div class="line">    addWatcher(&#123;propertyName, watcherFn, context&#125;) &#123;</div><div class="line">        <span class="keyword">this</span>.watcherList.push(&#123;propertyName, watcherFn, context&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除属性变化的回调函数</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param &#123;string&#125; propertyName 属性名</div><div class="line">     * @param &#123;Function&#125; watcherFn 回调函数</div><div class="line">     * @param &#123;Component&#125; context 组件</div><div class="line">     */</div><div class="line">    removeWatcher(&#123;propertyName, watcherFn, context&#125;) &#123;</div><div class="line">        <span class="keyword">this</span>.watcherList = filter(<span class="keyword">this</span>.watcherList, watcher =&gt; &#123;</div><div class="line">            <span class="keyword">return</span> watcher.propertyName !== propertyName</div><div class="line">                || watcher.watcherFn !== watcherFn</div><div class="line">                || watcher.context !== context;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 销毁</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     */</div><div class="line">    destroy() &#123;</div><div class="line">        <span class="keyword">this</span>.unsubscribe();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="避免写重复代码"><a href="#避免写重复代码" class="headerlink" title="避免写重复代码"></a>避免写重复代码</h1><p>目前想到的，就只是抽离复用代码，形成 helper 方法之类的。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文所述方案仅供参考，算是我初次使用 Redux 所想到的一些“套路”，不对之处静候读者指出，共同探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redux 提供的主要功能：全局数据管理，包括数据的更新、存储、数据变化通知。 Redux 的 store 中存放了当前应用的状态，可以根据这个状态完整恢复出当前应用的界面，因此在使用 Redux 的项目中，可以实现一个比较炫酷的功能：依据状态的前进、后退。&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
      <category term="Redux" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>如何展示表单控件</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BA%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/如何展示表单控件.html</id>
    <published>2016-12-15T14:34:00.000Z</published>
    <updated>2016-12-15T15:34:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Web 开发中，经常需要展示左右结构的表单。<a id="more"></a>如下所示：</p>
<p><img src="../images/2016-12-15/form.png" alt=""></p>
<p>面对这张图，最先想到的实现方式就是借助浮动：</p>
<iframe src="../demos/2016-12-15/form1.html" width="100%" height="250" frameborder="0" allowfullscreen></iframe>
<p>基本的结构就这样，看起来挺好的。</p>
<p>但是有一个忧伤的地方，左侧<code>form-key</code>部分的宽度太烦人，不同的表单<code>form-key</code>部分存在宽度差异，很难统一。如果把<code>form-key</code>部分统一设置成一个比较大的值，那么在<code>form-key</code>比较短的表单里面会非常难看。这样一来，只能选择不同的表单设置不同的<code>form-key</code>的宽度值，很烦人。</p>
<p><strong>如何让左侧的宽度自适应呢？</strong></p>
<p>从一位前端牛人学习到如下利用<code>table</code>布局的写法：</p>
<iframe src="../demos/2016-12-15/form2.html" width="100%" height="250" frameborder="0" allowfullscreen></iframe>
<p>此处<code>form-operations</code>部分有点小问题，<code>form-operations</code>是一个<code>table-row</code>，所以直接子元素应该是<code>table-cell</code>，改一改就好了。</p>
<p>同时也因为这个手误，发现在 IE9 中，鼠标 hover 到<code>table-row</code>上面去之后，会触发下面第一个<code>button</code>的 hover 效果。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Web 开发中，经常需要展示左右结构的表单。
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTTP请求重发</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/HTTP%E8%AF%B7%E6%B1%82%E9%87%8D%E5%8F%91.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/HTTP请求重发.html</id>
    <published>2016-07-05T16:00:00.000Z</published>
    <updated>2016-07-08T08:07:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 协议中，从语义上讲， GET 请求一般是获取服务器端的资源，不会对服务器数据造成副作用，可简单理解为一种“读”操作；而 POST 请求多用于更改（增、删、改）服务器上的资源，会产生一定的副作用。</p>
<p>所以，这样看起来，浏览器是不是就不会因为网络原因啥的自动重发 POST 请求吧？实际上是这样么？<br><a id="more"></a></p>
<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近在对接地图的一个数据录入接口：前端向后端发送一个 CSV 文件，后端将 CSV 文件中的数据解析出来，然后将数据通过地图接口导入到地图数据库。由于地图提供的接口有点怪异，批量导入数据的接口有一些问题，只能使用单条导入接口，所以在这里， CSV 文件里面有多少条数据，就会访问多少次地图的接口。</p>
<p>虽然有点坑，不过问题究竟是解决了，于是就这样上线了。</p>
<p>天有不测风云，遇到一个客户，一下要导入上千条数据，后端这样串行地一条一条去导入，很轻易地就花了好几分钟。而且还遇到一个诡异的现象：每条数据都导入了两次！</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>凭借多年的前端开发经验（不要脸了），立马大胆猜测，浏览器发送了两次请求。</p>
<p>于是先到谷歌开发者工具的 Network 标签页检查一下请求，发现此处只记录了一次请求，并且该请求没有响应，好像看不出来什么猫腻。再切换到 chrome://net-internals/ 中看看日志，发现一个 error code ， google 了一下，并没有什么结果，看起来也验证不了猜想。</p>
<p>然后再去找后端同学看看接口日志，是不是访问了两次，后端同学似乎稍微有点不太想打日志重新部署（过程比较麻烦），所以先放弃用这种方式求证。</p>
<p>那用啥求证呢？ Charles 吧。</p>
<p>在 Charles 中一看，发现发了四次请求，每次请求基本上都耗时六十多秒，每次都没有响应内容。</p>
<p>好了，看起来就是浏览器六十秒超时重发请求。</p>
<h1 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h1><p>可以转念一想，这对么？</p>
<ul>
<li>1、 POST 请求就这样轻易地被浏览器超时重发，难道浏览器开发者没考虑过数据重复发送的问题吗？表单 POST 请求手动刷新浏览器的时候都会弹窗提醒用户要不要重复提交数据呢！</li>
<li>2、为啥是六十秒呢？时间这么短吗？想想平时本地断点调试服务器代码的时候，那可是会超时老长时间的，所以这六十秒算个啥呢？</li>
</ul>
<p>搜一搜往上资料，发现 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.4" target="_blank" rel="external">HTTP/1.1 的一处规范</a> ：</p>
<blockquote>
<p>If an HTTP/1.1 client sends a request which includes a request body, but which does not include an Expect request-header field with the “100-continue” expectation, and if the client is not directly connected to an HTTP/1.1 origin server, and if the client sees the connection close before receiving any status from the server, the client SHOULD retry the request.</p>
</blockquote>
<p>大致意思就是说，如果发送一个请求到服务器端，该请求有请求体，但是请求头里面不包含“ 100-continue ”这种东西，并且客户端没有直接连接到原始的 HTTP/1.1 服务器，此时，如果客户端在接收到服务器发送的 HTTP 状态之前发现服务器主动关掉连接，那么客户端应该重试请求。</p>
<p>那看起来好像就是服务器端主动关掉了连接，导致浏览器重新发送请求了。</p>
<p>我们服务器端使用的是 Tomcat ，查一查资料，发现 Tomcat 默认的 connector 超时时间是六十秒，刚好吻合上了。</p>
<p>问题原因找到了，解决起来就轻松了，此处不赘述。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 协议中，从语义上讲， GET 请求一般是获取服务器端的资源，不会对服务器数据造成副作用，可简单理解为一种“读”操作；而 POST 请求多用于更改（增、删、改）服务器上的资源，会产生一定的副作用。&lt;/p&gt;
&lt;p&gt;所以，这样看起来，浏览器是不是就不会因为网络原因啥的自动重发 POST 请求吧？实际上是这样么？&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>karma 入门</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/karma-%E5%85%A5%E9%97%A8.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/karma-入门.html</id>
    <published>2016-07-01T02:35:44.000Z</published>
    <updated>2016-07-01T03:56:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了 karma 的入门知识点。<br><a id="more"></a></p>
<h1 id="什么是-karma"><a href="#什么是-karma" class="headerlink" title="什么是 karma"></a>什么是 karma</h1><p>karma 是一个提升测试效率的工具，帮助开发者更好更快速地在多种环境下执行测试代码，拿到测试结果。在运行的时候，它会自动启动配置好的浏览器，同时也会启动一个 node 服务器，然后在启动好的浏览器中执行测试代码，并将测试代码执行结果传回给 node 服务器，然后 node 服务器在打印出收到的执行结果。</p>
<h1 id="安装-karma"><a href="#安装-karma" class="headerlink" title="安装 karma"></a>安装 karma</h1><p>可以通过 npm 安装 karma ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 本地安装</div><div class="line">npm i karma --save-dev</div><div class="line"></div><div class="line">// 全局安装</div><div class="line">npm i karma -g</div></pre></td></tr></table></figure>
<h1 id="初始化-karma"><a href="#初始化-karma" class="headerlink" title="初始化 karma"></a>初始化 karma</h1><p>安装完成之后，切换到目标项目根目录，运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">karma init</div></pre></td></tr></table></figure>
<p>这样就会以向导的形式生成 karma 的配置文件 <code>karma.conf.js</code> ，文件内容大致为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Karma configuration</span></div><div class="line"><span class="comment">// Generated on Wed Jun 29 2016 23:22:24 GMT+0800 (CST)</span></div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</div><div class="line">    config.set(&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 根路径，后面配置的基本所有相对路径都会根据这个路径来构造。</span></div><div class="line">        basePath: <span class="string">''</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 使用到的框架</span></div><div class="line">        <span class="comment">// 目前支持的框架： https://npmjs.org/browse/keyword/karma-adapter</span></div><div class="line">        frameworks: [<span class="string">'jasmine'</span>, <span class="string">'requirejs'</span>],</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 将会在浏览器里面执行的代码</span></div><div class="line">        files: [</div><div class="line">            <span class="string">'test/main.js'</span>,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">pattern</span>: <span class="string">'src/**/*.js'</span>,</div><div class="line">                <span class="comment">// false 表示初始化的时候不会使用 script 标签直接将相关 js 引入到浏览器，需要自己写代码加载</span></div><div class="line">                included: <span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">pattern</span>: <span class="string">'test/**/*Spec.js'</span>,</div><div class="line">                <span class="attr">included</span>: <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        ],</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 需要从 files 中排除掉的文件</span></div><div class="line">        exclude: [],</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 需要做预处理的文件，以及这些文件对应的预处理器。</span></div><div class="line">        <span class="comment">// 此处就可以将 coffee 、 ES6 等代码转换一下。</span></div><div class="line">        preprocessors: &#123;</div><div class="line">            <span class="string">'src/**/*.js'</span>: [<span class="string">'babel'</span>, <span class="string">'coverage'</span>],</div><div class="line">            <span class="string">'test/**/!(main).js'</span>: [<span class="string">'babel'</span>, <span class="string">'coverage'</span>],</div><div class="line">            <span class="string">'node_modules/protectobject/src/**/*.js'</span>: [<span class="string">'babel'</span>]</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="comment">// babel 预处理器的配置</span></div><div class="line">        babelPreprocessor: &#123;</div><div class="line">            <span class="attr">options</span>: &#123;</div><div class="line">                <span class="attr">presets</span>: [<span class="string">'es2015'</span>, <span class="string">'stage-0'</span>],</div><div class="line">                <span class="attr">plugins</span>: [<span class="string">'transform-decorators-legacy'</span>, <span class="string">'transform-es2015-modules-amd'</span>]</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="comment">// 覆盖率报告器配置</span></div><div class="line">        coverageReporter: &#123;</div><div class="line">            <span class="attr">type</span>: <span class="string">'html'</span>,</div><div class="line">            <span class="attr">dir</span>: <span class="string">'coverage'</span></div><div class="line">        &#125;,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 实际使用的报告期</span></div><div class="line">        <span class="comment">// 可用的报告器： https://npmjs.org/browse/keyword/karma-reporter</span></div><div class="line">        reporters: [<span class="string">'dots'</span>, <span class="string">'coverage'</span>],</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 服务器端口号</span></div><div class="line">        port: <span class="number">9876</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 在输出内容（报告器和日志）中启用/禁用颜色</span></div><div class="line">        colors: <span class="literal">true</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 日志级别</span></div><div class="line">        <span class="comment">// 取值： config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG</span></div><div class="line">        logLevel: config.LOG_INFO,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 启用/禁用监视文件变化重新执行测试的功能</span></div><div class="line">        autoWatch: <span class="literal">true</span>,</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 要测试的目标环境</span></div><div class="line">        browsers: [<span class="string">'Chrome'</span>, <span class="string">'Firefox'</span>, <span class="string">'Safari'</span>],</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// Continuous Integration mode</span></div><div class="line">        <span class="comment">// if true, Karma captures browsers, runs the tests and exits</span></div><div class="line">        singleRun: <span class="literal">false</span>,</div><div class="line"></div><div class="line">        <span class="comment">// Concurrency level</span></div><div class="line">        <span class="comment">// how many browser should be started simultaneous</span></div><div class="line">        concurrency: <span class="literal">Infinity</span></div><div class="line">    &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="配置-Require-js"><a href="#配置-Require-js" class="headerlink" title="配置 Require.js"></a>配置 Require.js</h1><p>对于 Require.js ，还要注意配置一个入口文件，主要用于配置 Require.js 的模块信息等。</p>
<p>上述 karma 配置文件中的 test/main.js 即为 Require.js 的入口文件，在该文件中的代码一般来说应该是这样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> TEST_REGEXP = <span class="regexp">/(spec|test)\.js$/i</span>;</div><div class="line"><span class="keyword">var</span> allTestFiles = [];</div><div class="line"></div><div class="line"><span class="comment">// Get a list of all the test files to include</span></div><div class="line"><span class="built_in">Object</span>.keys(<span class="built_in">window</span>.__karma__.files).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (TEST_REGEXP.test(file)) &#123;</div><div class="line">    <span class="comment">// Normalize paths to RequireJS module names.</span></div><div class="line">    <span class="comment">// If you require sub-dependencies of test files to be loaded as-is (requiring file extension)</span></div><div class="line">    <span class="comment">// then do not normalize the paths</span></div><div class="line">    <span class="keyword">var</span> normalizedTestModule = file.replace(<span class="regexp">/^\/base\/|\.js$/g</span>, <span class="string">''</span>);</div><div class="line">    allTestFiles.push(normalizedTestModule);</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">require</span>.config(&#123;</div><div class="line">  <span class="comment">// Karma serves files under /base, which is the basePath from your config file</span></div><div class="line">  baseUrl: <span class="string">'/base/src'</span>,</div><div class="line"></div><div class="line">  <span class="comment">// example of using a couple of path translations (paths), to allow us to refer to different library dependencies, without using relative paths</span></div><div class="line">  paths: &#123;</div><div class="line">    <span class="string">'jquery'</span>: <span class="string">'../lib/jquery'</span>,</div><div class="line">    <span class="string">'underscore'</span>: <span class="string">'../lib/underscore'</span>,</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// example of using a shim, to load non AMD libraries (such as underscore)</span></div><div class="line">  shim: &#123;</div><div class="line">    <span class="string">'underscore'</span>: &#123;</div><div class="line">      <span class="attr">exports</span>: <span class="string">'_'</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="comment">// dynamically load all test files</span></div><div class="line">  deps: allTestFiles,</div><div class="line"></div><div class="line">  <span class="comment">// we have to kickoff jasmine, as it is asynchronous</span></div><div class="line">  callback: <span class="built_in">window</span>.__karma__.start</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h1><p>运行如下命令，执行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">karma start</div></pre></td></tr></table></figure>
<h1 id="karma-分析"><a href="#karma-分析" class="headerlink" title="karma 分析"></a>karma 分析</h1><p>在执行测试的时候，点击 <code>debug</code> 按钮，进入 debug 页面，然后打开浏览器开发者工具，可以看到在 HTML 中有一段 js 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Configure our Karma</span></div><div class="line">    <span class="built_in">window</span>.__karma__.config = &#123;<span class="string">"args"</span>:[],<span class="string">"useIframe"</span>:<span class="literal">true</span>,<span class="string">"captureConsole"</span>:<span class="literal">true</span>,<span class="string">"clearContext"</span>:<span class="literal">true</span>&#125;;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// All served files with the latest timestamps</span></div><div class="line">    <span class="built_in">window</span>.__karma__.files = &#123;</div><div class="line">  <span class="string">'/base/node_modules/requirejs/require.js'</span>: <span class="string">'2c8b45573db27c131094a113e995236d20f043bb'</span>,</div><div class="line">  <span class="string">'/base/node_modules/karma-requirejs/lib/adapter.js'</span>: <span class="string">'2621a4400d4a8a49588243fce2d8609ef950b46a'</span>,</div><div class="line">  <span class="string">'/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js'</span>: <span class="string">'391e45351df9ee35392d2e5cb623221a969fc009'</span>,</div><div class="line">  <span class="string">'/base/node_modules/karma-jasmine/lib/boot.js'</span>: <span class="string">'945a38bf4e45ad2770eb94868231905a04a0bd3e'</span>,</div><div class="line">  <span class="string">'/base/node_modules/karma-jasmine/lib/adapter.js'</span>: <span class="string">'7975a273517f1eb29d7bd018790fd4c7b9a485d5'</span>,</div><div class="line">  <span class="string">'/base/test/main.js'</span>: <span class="string">'fc5206f4dff3b583db818cb10ed7c5cade572896'</span>,</div><div class="line">  <span class="string">'/base/src/State.js'</span>: <span class="string">'db89a58b4570983b8f8febfd4dedbc586c353670'</span>,</div><div class="line">  <span class="string">'/base/test/StateSpec.js'</span>: <span class="string">'faf31b373690a6d7a7035fdfdc9c85d906ace5c1'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到 <code>window.__karma__.files</code> 中列出了所有的可能会在浏览器中执行的 js ，如果通过 Require.js 加载这里没有列举出来的 js ，就会报错。</p>
<p>然后再看下面的一堆 script 标签，大致是这样的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/node_modules/requirejs/require.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/node_modules/karma-requirejs/lib/adapter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/node_modules/jasmine-core/lib/jasmine-core/jasmine.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/node_modules/karma-jasmine/lib/boot.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/node_modules/karma-jasmine/lib/adapter.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/base/test/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span></div><div class="line">    <span class="built_in">window</span>.__karma__.loaded();</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到，直接引入了 require.js 、 karma 相关的一堆 js 、jasmine 相关的 js ，还直接引入了刚才配置的 test/main.js （Require.js 入口文件）。注意，此处并没有直接引入 <code>included: false</code> 的 js 。</p>
<h2 id="URL-路径中的-base"><a href="#URL-路径中的-base" class="headerlink" title="URL 路径中的 base"></a>URL 路径中的 <code>base</code></h2><p>如果仔细看各种资源请求的 URL 地址，会发现除了 <code>debug.js</code> 和 <code>context.js</code> 之外，其它 js 文件都会以 <code>/base</code> 开头，在配置 Require.js 的时候，务必注意这一点。</p>
<h2 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h2><p>可以引入 karma 的 coverage 插件来查看测试覆盖率，该插件会在目标代码中插入很多额外的代码，用于判断测试代码执行流程有没有走到这些地方。在 debug 的时候，最好关掉 coverage 功能，不然这些额外的代码非常影响调试。</p>
<p>另外 karma-coverage-es6 声称支持 ES6 ，但是似乎并不行？</p>
<h2 id="jasmine-的-HTML-reporter"><a href="#jasmine-的-HTML-reporter" class="headerlink" title="jasmine 的 HTML reporter"></a>jasmine 的 HTML reporter</h2><p>默认情况下，浏览器中 debug 页面是不会输出任何 jamine 测试结果的，可以借助 <code>karma-jasmine-html-reporter</code> 解决这个问题。</p>
<p>但是，<code>karma-jasmine-html-reporter</code> 有坑，在该插件的 index.js 中，有这样一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> createPattern = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;<span class="attr">pattern</span>: path, <span class="attr">included</span>: <span class="literal">true</span>, <span class="attr">served</span>: <span class="literal">true</span>, <span class="attr">watched</span>: <span class="literal">false</span>&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> initReporter = <span class="function"><span class="keyword">function</span>(<span class="params">files,  baseReporterDecorator</span>) </span>&#123;</div><div class="line"></div><div class="line">  baseReporterDecorator(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">  files.unshift(createPattern(__dirname + <span class="string">'/lib/adapter.js'</span>));</div><div class="line">  files.unshift(createPattern(__dirname + <span class="string">'/lib/html.jasmine.reporter.js'</span>));</div><div class="line">  files.unshift(createPattern(__dirname + <span class="string">'/css/jasmine.css'</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line">initReporter.$inject = [<span class="string">'config.files'</span>,  <span class="string">'baseReporterDecorator'</span>];</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="string">'reporter:kjhtml'</span>: [<span class="string">'type'</span>, initReporter]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>files</code> 指的就是 karma.conf.js 中配置的 files ，此处使用 <code>unshift</code> 方法将这堆 js 、 css 放在了 files 最前面，这样就会导致 <code>html.jasmine.reporter.js</code> 先于 <code>jasmine.js</code> 加载，从而报错（<code>html.jasmine.reporter.js</code> 是要依赖 <code>jasmine.js</code> 的），所以这里最好根据项目的实际情况，合理调整一下顺序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了 karma 的入门知识点。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>受保护的对象</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%9A%84%E5%AF%B9%E8%B1%A1.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/受保护的对象.html</id>
    <published>2016-06-19T08:27:44.000Z</published>
    <updated>2016-07-01T03:56:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 JavaScript 没有多线程变量共享的问题，但是在一些场景中，我们还是希望能对某些对象进行适当的保护（锁定），防止发生一些不可预期的错误。</p>
<p>本文主要从如下两个实际场景展开：</p>
<ul>
<li>任务执行器；</li>
<li>事件基类。</li>
</ul>
<a id="more"></a>
<h1 id="任务执行器"><a href="#任务执行器" class="headerlink" title="任务执行器"></a>任务执行器</h1><p>现在，我们需要一个 DOM 操作的任务执行器，这个任务执行器满足的主要功能有：</p>
<ul>
<li>能够添加任务；</li>
<li>能够批量执行任务；</li>
<li>能够随时启动和停止任务的执行。</li>
</ul>
<p>为啥需要这么个东西呢？假设其中有下面三步 DOM 操作：</p>
<ul>
<li>设置节点 a 的文本： <code>a.innerText = &#39;text1&#39;</code> ；</li>
<li>设置节点 a 的文本： <code>a.innerText = &#39;text2&#39;</code> ；</li>
<li>设置节点 a 的文本： <code>a.innerText = &#39;text3&#39;</code> 。</li>
</ul>
<p>如果老老实实设置三次，感觉太不划算了！实际上只需要设置最后一次就好了，这样就可以减少两次无谓的 DOM 操作了。</p>
<p>初步看起来，我们的任务执行器代码大致会像这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> TASKS = <span class="built_in">Symbol</span>(<span class="string">'tasks'</span>);</div><div class="line"><span class="keyword">const</span> COUNTER = <span class="built_in">Symbol</span>(<span class="string">'counter'</span>);</div><div class="line"><span class="keyword">const</span> EXECUTE = <span class="built_in">Symbol</span>(<span class="string">'execute'</span>);</div><div class="line"><span class="keyword">const</span> IS_RUNNING = <span class="built_in">Symbol</span>(<span class="string">'isRunning'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">DomUpdater</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">this</span>[TASKS] = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>[COUNTER] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取任务ID，每一种类型操作对应一个任务ID，</div><div class="line">     * 比如对某个节点的innerText就可以算是一种类型的操作，具有唯一的任务ID</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @return &#123;string&#125; 任务ID</div><div class="line">     */</div><div class="line">    getTaskId() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span> + ++<span class="keyword">this</span>[COUNTER];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 添加任务函数</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param &#123;Function&#125; taskFn   任务函数</div><div class="line">     * @param &#123;Function&#125; notifyFn 任务执行完成之后的回调函数</div><div class="line">     */</div><div class="line">    add(taskId, taskFn, notifyFn) &#123;</div><div class="line">        <span class="keyword">const</span> task = <span class="keyword">this</span>[TASKS][taskId] || &#123;&#125;;</div><div class="line"></div><div class="line">        task.taskFn = taskFn;</div><div class="line"></div><div class="line">        <span class="comment">// 为啥notifyFns会是一个数组，而taskFn不是数组呢？</span></div><div class="line">        <span class="comment">// 因为我们期望后续同类型的（taskId相同）的任务能够覆盖掉之前的任务，</span></div><div class="line">        <span class="comment">// 而之前任务的回调函数需要保留，这样就可以保证一定会通知外界某个任务已经执行完成了。</span></div><div class="line">        task.notifyFns = task.notifyFns || [];</div><div class="line">        task.notifyFns.push(notifyFn);</div><div class="line"></div><div class="line">        <span class="keyword">this</span>[TASKS][taskId] = task;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>[EXECUTE]();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 启动任务执行</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     */</div><div class="line">    start() &#123;</div><div class="line">        <span class="keyword">this</span>[IS_RUNNING] = <span class="literal">true</span>;</div><div class="line">        <span class="keyword">this</span>[EXECUTE]();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    stop() &#123;</div><div class="line">        <span class="keyword">this</span>[IS_RUNNING] = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 执行任务</div><div class="line">     *</div><div class="line">     * @private</div><div class="line">     */</div><div class="line">    [EXECUTE]() &#123;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>[IS_RUNNING]) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">window</span>.requestAnimationFrame(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> taskId <span class="keyword">in</span> <span class="keyword">this</span>[TASKS]) &#123;</div><div class="line">                <span class="keyword">const</span> task = <span class="keyword">this</span>[TASKS][taskId];</div><div class="line">                <span class="keyword">if</span> (!task) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">let</span> result;</div><div class="line">                <span class="keyword">let</span> error;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    result = task.taskFn();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">catch</span> (err) &#123;</div><div class="line">                    error = err;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, il = task.notifyFns.length; i &lt; il; ++i) &#123;</div><div class="line">                    task.notifyFns[i](error, result);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">this</span>[TASKS][taskId] = <span class="literal">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    destroy() &#123;</div><div class="line">        <span class="keyword">this</span>[TASKS] = <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，看起来似乎可以了，那就到实际环境遛遛吧！</p>
<p>不遛不知道，一遛吓一跳，跳出来一些莫名其妙的问题：</p>
<ul>
<li>代码的第90行报<code>this[TASKS]</code>不存在；</li>
<li>总是会有任务的回调函数没有被调用。</li>
</ul>
<p>仔细分析一下代码，可以发现：</p>
<ul>
<li>对于第一个问题，在执行传入 <code>requestAnimationFrame</code> 的回调函数的时候，某个 taskFn 或者 notifyFn 可能会调用 <code>destroy()</code> 方法，从而将 <code>this[TASKS]</code> 设为了 false ，然后再执行到90行，就报错了。</li>
<li>对于第二个问题，假设有两个同类型的任务，在 ‘EXECUTE’ 中调用第一个任务的 <code>notifyFn</code> 的时候，添加进第二个任务（调用了 add() 方法），然后执行到90行，将该类型任务置为 null ，这样一来，第二个任务的回调函数就没有机会执行了。</li>
</ul>
<p>所以，问题的根源就在任务执行过程中调用了不可控的外部函数，从而导致 <code>this[TASKS]</code> 发生变化。</p>
<p>对于第一个类型的问题，可以简单地使用 IS_RUNNING 状态绕开。对于第二种类型的问题，就最好找一种更优雅通用的解决方案了。</p>
<p>我们注意到，传入 <code>requestAnimationFrame</code> 的回调函数体（行范围：[72-90]）是一个敏感地带，执行这块代码的时候，应该将 <code>this[TASKS]</code> 锁定，防止不可控的外部函数（ taskFn 和 notifyFn ）对其进行干扰。</p>
<p>其实简单说起来，这类问题就是 <code>for in</code> 循环中，被遍历的对象应该是<code>可读的</code>的一个变体，所以，可以抽离出来一个比较通用的类，具体实现代码请移步到<a href="https://github.com/elegant-view/vtpl/blob/master/src/ProtectObject.js" target="_blank" rel="external">这里</a>。</p>
<p>现在，我们的<code>DOM 操作任务执行器</code>看起来就像<a href="https://github.com/elegant-view/vtpl/blob/master/src/DomUpdater.js" target="_blank" rel="external">这样了</a>。</p>
<p>目前看来，这个 <code>DomUpdater</code> 还有些小地方需要优化：</p>
<ul>
<li>TASKS 任务遍历顺序不应该依赖于对象上键的遍历顺序。</li>
<li>TASKS 对象的键并没有销毁，所以每次任务执行的时候，遍历次数都会只增不减。</li>
</ul>
<h1 id="事件基类"><a href="#事件基类" class="headerlink" title="事件基类"></a>事件基类</h1><p>在搭建前端框架的时候，一般都会期望各个功能模块能够解耦合。通常情况下，会使用事件来达到这个效果。</p>
<p>第一次写这个类的话，很有可能就写成了这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;isFunction&#125; <span class="keyword">from</span> <span class="string">'./util'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> EVENTS = <span class="built_in">Symbol</span>(<span class="string">'events'</span>);</div><div class="line"><span class="keyword">const</span> STATE = <span class="built_in">Symbol</span>(<span class="string">'state'</span>);</div><div class="line"><span class="keyword">const</span> STATE_READY = <span class="built_in">Symbol</span>(<span class="string">'stateReady'</span>);</div><div class="line"><span class="keyword">const</span> STATE_DESTROIED = <span class="built_in">Symbol</span>(<span class="string">'stateDestroied'</span>);</div><div class="line"><span class="keyword">const</span> CHECK_READY = <span class="built_in">Symbol</span>(<span class="string">'checkReady'</span>);</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">this</span>[EVENTS] = &#123;&#125;;</div><div class="line">        <span class="keyword">this</span>[STATE] = STATE_READY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在调用on、trigger、safeTrigger、asyncTrigger、off的时候，要检查一下当前event对象的状态。</div><div class="line">     *</div><div class="line">     * @private</div><div class="line">     */</div><div class="line">    [CHECK_READY]() &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[STATE] !== STATE_READY) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'wrong event state: the event object is not ready.'</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 绑定事件</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param  &#123;string&#125;   eventName 事件名字</div><div class="line">     * @param  &#123;Function&#125; fn        回调函数</div><div class="line">     * @param  &#123;Object=&#125;   context   上下文对象</div><div class="line">     */</div><div class="line">    on(eventName, fn, context) &#123;</div><div class="line">        <span class="keyword">this</span>[CHECK_READY]();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isFunction(fn)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> events = <span class="keyword">this</span>[EVENTS];</div><div class="line">        events[eventName] = events[eventName] || [];</div><div class="line">        events[eventName].push(&#123;fn, context&#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 同步触发事件</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param  &#123;string&#125;    eventName 事件名字</div><div class="line">     * @param  &#123;...[*]&#125; args      要传给事件回调函数的参数列表</div><div class="line">     */</div><div class="line">    trigger(eventName, ...args) &#123;</div><div class="line">        <span class="keyword">this</span>[CHECK_READY]();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> fnObjs = <span class="keyword">this</span>[EVENTS][eventName];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> fnObj <span class="keyword">of</span> fnObjs) &#123;</div><div class="line">            fnObj.context::fnObj.fn(...args);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除事件回调</div><div class="line">     *</div><div class="line">     * @public</div><div class="line">     * @param  &#123;...[*]&#125; args eventName，fn，context</div><div class="line">     * @param  &#123;string=&#125; args.0 参数名字</div><div class="line">     * @param  &#123;function=&#125; args.1 回调函数</div><div class="line">     * @param  &#123;Object=&#125; args.2 上下文对象</div><div class="line">     */</div><div class="line">    off(...args) &#123;</div><div class="line">        <span class="keyword">this</span>[CHECK_READY]();</div><div class="line"></div><div class="line">        <span class="keyword">let</span> [eventName, fn, context] = args;</div><div class="line">        <span class="keyword">if</span> (args.length === <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">this</span>[EVENTS] = &#123;&#125;;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> iterator = <span class="function"><span class="params">checkFn</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> fnObjs = <span class="keyword">this</span>[EVENTS][eventName];</div><div class="line">            <span class="keyword">let</span> newFnObjs = [];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> fnObj <span class="keyword">of</span> fnObjs) &#123;</div><div class="line">                <span class="keyword">if</span> (checkFn(fnObj)) &#123;</div><div class="line">                    newFnObjs.push(fnObj);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">this</span>[EVENTS][eventName] = newFnObjs;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (args.length === <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">this</span>[EVENTS][eventName] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args.length === <span class="number">2</span>) &#123;</div><div class="line">            iterator(<span class="function"><span class="params">fnObj</span> =&gt;</span> fn !== fnObj.fn);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (args.length === <span class="number">3</span>) &#123;</div><div class="line">            iterator(<span class="function"><span class="params">fnObj</span> =&gt;</span> fn !== fnObj.fn || context !== fnObj.context);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    destroy() &#123;</div><div class="line">        <span class="keyword">this</span>[EVENTS] = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">this</span>[STATE] = STATE_DESTROIED;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 <code>trigger()</code> 循环事件处理器的时候，事件回调函数很可能会通过 <code>on()</code> 间接修改 <code>this[EVENTS]</code> ，因此，我们需要使用 <a href="https://github.com/elegant-view/vtpl/blob/master/src/ProtectObject.js" target="_blank" rel="external">ProtectObject</a> 来对 <code>this[EVENTS]</code> 进行锁定。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本质上，这类问题就是传入的函数中做了不希望做的事情，所以如何禁止或者兼容这些<code>不希望做的事情</code>是关键点。</p>
<p>本文为作者在实践中总结出来的方案，能力有限，期待读者提出更好的方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 JavaScript 没有多线程变量共享的问题，但是在一些场景中，我们还是希望能对某些对象进行适当的保护（锁定），防止发生一些不可预期的错误。&lt;/p&gt;
&lt;p&gt;本文主要从如下两个实际场景展开：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务执行器；&lt;/li&gt;
&lt;li&gt;事件基类。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>WEB 中的文件下载</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/filedownload.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/filedownload.html</id>
    <published>2016-06-17T00:59:00.000Z</published>
    <updated>2016-06-17T16:12:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 WEB 开发中，我们会期望用户在点击某个链接的时候，下载一个文件（不管这个文件能不能被浏览器解析，都要下载）。以前接触过一种方式，就是在响应 header 中设置 <code>force-download</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Content-Type: application/force-download</div><div class="line">Content-Disposition: attachment; filename=&quot;test.zip&quot;</div></pre></td></tr></table></figure>
<p>然而，这是一种 hack 方式，并不推荐使用：<br><a id="more"></a></p>
<blockquote><p>Content-Type: application/force-download means “I, the web server, am going to lie to you (the browser) about what this file is so that you will not treat it as a PDF/Word Document/MP3/whatever and prompt the user to save the mysterious file to disk instead”. It is a dirty hack that breaks horribly when the client doesn’t do “save to disk”.</p>
<footer><strong>Quentin</strong><cite><a href="http://stackoverflow.com/a/10616753/3468416" target="_blank" rel="external">Utility of HTTP header “Content-Type: application/force-download” for mobile?</a></cite></footer></blockquote>
<p>有位小伙伴就遇到了不奏效的情况：</p>
<blockquote><p>ATTENTION:<br>If you use any of the lines below your download will probably NOT WORK on Android 2.1.<br><br></p>
<p>Content-Type: application/force-download<br>Content-Disposition: attachment; filename=MyFileName.ZIP<br>Content-Disposition: attachment; filename=”MyFileName.zip”<br>Content-Disposition: attachment; filename=”MyFileName.ZIP”;</p>
<footer><strong>Jörg Wagner</strong><cite><a href="http://www.digiblog.de/2011/04/android-and-the-download-file-headers/" target="_blank" rel="external">Android and the HTTP download file headers</a></cite></footer></blockquote>
<p>那么，究竟怎么办呢？接下来描述我的同事和我遇到的问题。</p>
<h1 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h1><p>最近接手了一个新项目，今天刚好有空熟悉一下之前的功能。于是打开线上地址，输入测试账号，进入一个列表页面，这个列表页面提供了下载数据为 Excel 文件的功能，点了一下<code>下载</code>链接，猛然发现，下载的文件名字怎么是 <code>download</code> ？为啥呢？</p>
<p>我用的浏览器是 Chrome 51 ，系统是 OS EI Capitan 10.11.5 。</p>
<p>我一同事 Chrome 47，可以完全正常下载！</p>
<p>先看看为啥我的浏览器不行吧！</p>
<h1 id="第一步探索"><a href="#第一步探索" class="headerlink" title="第一步探索"></a>第一步探索</h1><p>打开 Chrome 开发者工具，查看 HTTP 请求，发现响应头部有如下两项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Content-Type: application/octet-stream;charset=GBK</div><div class="line">Content-Disposition: attachment; filename=&quot;%D6%D0%CE%C4.xlsx</div></pre></td></tr></table></figure>
<p>噢，filename 那里多了一个双引号，去掉吧！</p>
<h1 id="第二步探索"><a href="#第二步探索" class="headerlink" title="第二步探索"></a>第二步探索</h1><p>然而，引号去掉之后，问题依旧！什么情况？难道是 filename 需要引号包起来？</p>
<p>好吧，包起来试试！</p>
<h1 id="第三步探索"><a href="#第三步探索" class="headerlink" title="第三步探索"></a>第三步探索</h1><p>包起来后问题依旧，什么鬼？</p>
<p>灵机一动，去看看别人怎么做的吧！于是找到别人网站一个下载 Excel 的页面，点击下载，发现响应 header 里面是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8</div><div class="line">Content-Disposition: inline;filename=&quot;%D6%D0%CE%C4.xlsx&quot;;filename*=utf-8&apos;&apos;%D6%D0%CE%C4.xlsx</div></pre></td></tr></table></figure>
<p>Content-Type 指明了具体的文件类型，然后 Content-Disposition 多了一个 <code>filename*=</code> ，这是什么东西？ <code>utf-8</code> 是什么编码？</p>
<p>经过一堆胡乱搜索，猜测 utf-8 就是文件名的编码。为啥文件名要编码呢？呃，HTTP header 里面还未见过中文……</p>
<p>好了，我们后端的代码大致做法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</div><div class="line">response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename=\""</span> + <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"GBK"</span>), <span class="string">"ISO-8859-1"</span>) + <span class="string">"\".xlsx"</span>);</div></pre></td></tr></table></figure>
<p>看起来，只需要用 <code>filename*=</code> 附上编码就行了，于是后端代码改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</div><div class="line">response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename=\""</span> + <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"GBK"</span>), <span class="string">"ISO-8859-1"</span>) + <span class="string">"\".xlsx;filename*=GBK''"</span> + <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"GBK"</span>), <span class="string">"ISO-8859-1"</span>));</div></pre></td></tr></table></figure>
<p>好了，我再点击下载，没问题！</p>
<h1 id="第四步探索"><a href="#第四步探索" class="headerlink" title="第四步探索"></a>第四步探索</h1><p>看起来好像是 OK 了，但是，用 IE 试一下，又不正常了，文件名字不对了！</p>
<p>为什么呢？别人网站在 IE 下都能正常下载的！现在主要有两处区别：</p>
<ul>
<li>我们的 Content-Type 没有写具体；</li>
<li>我们使用了 GBK 编码。</li>
</ul>
<p>一思索，感觉编码的嫌疑较大，为啥呢？因为对于文件下载，浏览器根本不用管文件内容是个啥，只需要按照二进制流写入本地磁盘就好了，并且，此处也只是文件名错了，下载下来的文件内容还是没问题的。</p>
<p>那就改编码吧，改成 UTF-8 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">response.addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/octet-stream"</span>);</div><div class="line">response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename=\""</span> + <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"ISO-8859-1"</span>) + <span class="string">"\".xlsx;filename*=UTF-8''"</span> + <span class="keyword">new</span> String(fileName.getBytes(<span class="string">"UTF-8"</span>), <span class="string">"ISO-8859-1"</span>));</div></pre></td></tr></table></figure>
<p>经测试，一切正常！</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在文件下载功能中，一般都会借助于这两个 header 来达到效果，那么两个 header 的具体作用是什么呢？</p>
<ul>
<li>Content-Type：告诉浏览器当前的响应体是个什么类型的数据。当其为 application/octet-stream 的时候，就说明 body 里面是一堆不知道是啥的二进制数据。</li>
<li>Content-Disposition：用于向浏览器提供一些关于如何处理响应内容的额外的信息，同时也可以附带一些其它数据，比如在保存响应体到本地的时候应该使用什么样的文件名。</li>
</ul>
<p>细想一下， Content-Type 好像对于文件下载没什么作用？事实上的确如此。可是再想一下，如果浏览器不理会 Content-Disposition ，不下载文件怎么办？如果此时提供了 Content-Type ,至少浏览器还有机会根据具体的 Content-Type 对响应体进行处理。</p>
<p>可是为什么浏览器会不理会 Content-Disposition 呢？因为这个 Content-Disposition 头部并不是 HTTP 标准中的内容，只是被浏览器广泛实现的一个 header 而已。</p>
<p>话题转一转， Content-Disposition 的语法见<a href="https://tools.ietf.org/html/rfc6266#section-4.1" target="_blank" rel="external">此处</a>，其中相对重要的点此处罗列一下：</p>
<ul>
<li>常用的 disponsition-type 有 <code>inline</code> 和 <code>attachment</code> ：<ul>
<li>inline：建议浏览器使用默认的行为处理响应体。</li>
<li>attachment：建议浏览器将响应体保存到本地，而不是正常处理响应体。</li>
</ul>
</li>
<li>Content-Disposition 中可以传入 filename 参数，有两种形式：<ul>
<li>filename=yourfilename.suffix：直接指明文件名和后缀。</li>
<li>filename*=utf-8’’yourfilename.suffix：指定了文件名编码。其中，编码后面那对单引号中还可以填入内容，此处不赘述，可参考<a href="https://tools.ietf.org/html/rfc6266" target="_blank" rel="external">规范</a>。</li>
<li>有些浏览器不认识 <code>filename*=utf-8&#39;&#39;yourfilename.suffix</code> （估计因为这东西比较复杂），所以最好带上 <code>filename=yourfilename.suffix</code> 。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 WEB 开发中，我们会期望用户在点击某个链接的时候，下载一个文件（不管这个文件能不能被浏览器解析，都要下载）。以前接触过一种方式，就是在响应 header 中设置 &lt;code&gt;force-download&lt;/code&gt; ：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Content-Type: application/force-download&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;Content-Disposition: attachment; filename=&amp;quot;test.zip&amp;quot;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，这是一种 hack 方式，并不推荐使用：&lt;br&gt;
    
    </summary>
    
    
      <category term="HTTP" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>使用 marked 解析 markdown 之缩进</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E4%BD%BF%E7%94%A8%20marked%20%E8%A7%A3%E6%9E%90%20markdown%20%E4%B9%8B%E7%BC%A9%E8%BF%9B.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/使用 marked 解析 markdown 之缩进.html</id>
    <published>2016-06-15T08:12:00.000Z</published>
    <updated>2016-06-17T12:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面一篇文章<a href="/blogs/site//blogs/使用marked解析markdown.html" title="使用 marked 解析 markdown">使用 marked 解析 markdown</a>中，大致介绍了一下 marked 使用过程中的一些问题，今天又再次遇到 ETPL 的 markdown 过滤器嵌套带来的问题。</p>
<a id="more"></a>
<h1 id="遇见问题"><a href="#遇见问题" class="headerlink" title="遇见问题"></a>遇见问题</h1><p>这次，我想在 table 的 td 里面写 markdown ，期望效果看起来像是这样的：</p>
<img src="/blogs/site/images/14.png">
<p>而 markdown 代码，我是这样写的：</p>
<img src="/blogs/site/images/15.png">
<p>然后出来的效果是这样：</p>
<img src="/blogs/site/images/16.png">
<p>注意黑色的那段代码块，没缩进了！</p>
<p>什么情况？为啥会没缩进呢？</p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>仔细一看 markdown 代码，发现里面出现了过滤器嵌套，也就是说，里面那块 markdown 代码会被处理两次！</p>
<h1 id="尝试解决方案1"><a href="#尝试解决方案1" class="headerlink" title="尝试解决方案1"></a>尝试解决方案1</h1><p>既然处理了两次，那么就得想办法只处理一次，于是将 markdown 代码改成这样：</p>
<img src="/blogs/site/images/17.png">
<p>看起来每个 markdown 块都只被处理了一次，应该可以了吧！</p>
<p>于是，我得到了这个效果：</p>
<img src="/blogs/site/images/14.png">
<p>这个看起来好像没啥问题了。</p>
<p>但是，结合 filter 代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etpl = <span class="built_in">require</span>(<span class="string">'etpl'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line">etpl.addFilter(<span class="string">'markdown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">source, useExtra</span>) </span>&#123;</div><div class="line">    source = source.replace(<span class="regexp">/(^\n+|\n+$)/g</span>, <span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> uselessSpaceCount = source.match(<span class="regexp">/^\s*/</span>)[<span class="number">0</span>].length;</div><div class="line">    source = source.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^ &#123;'</span> + uselessSpaceCount + <span class="string">'&#125;'</span>, <span class="string">'gm'</span>), <span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> marked(source);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>发现：第三个 &lt;!– filter: markdown() –&gt; 会导致自己的 markdown 块缩进出问题。</p>
<h1 id="尝试解决方案2"><a href="#尝试解决方案2" class="headerlink" title="尝试解决方案2"></a>尝试解决方案2</h1><p>再来仔细玩味一下内嵌 filter 的处理流程吧，希望能找到解决方案。</p>
<p>经过各种 debug ，发现整个处理流程是这样的：</p>
<ul>
<li>1、先处理最里面的 markdown 块（这是是 ETPL 的处理流程），然后生成对应的 HTML 代码，替换掉之前的 markdown 代码；</li>
<li>2、再处理外层的 markdown 块，这个块包含了第一步中生成的 HTML 代码块。于是在替换每行空格的时候，同样会替换掉第一步中生成的 code 标签中每一行前面相应的空格。</li>
</ul>
<p>好了，现在为啥缩进会出问题的原因已经具体定位了，咋办呢？</p>
<p>在第2步调用 marked 解析之前，完全可以把第一步中生成的 HTML 代码拿出来，这样第2步处理的时候就不会去掉 code 块中的有用空格了。这样一来，过滤器关键部分的代码就变成了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> renderer = <span class="keyword">new</span> marked.Renderer();</div><div class="line"><span class="built_in">require</span>(<span class="string">'etpl'</span>).addFilter(<span class="string">'markdown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">source, useExtra</span>) </span>&#123;</div><div class="line">    <span class="comment">// 把内嵌的 markdown 拿出来，防止多次转换</span></div><div class="line">    <span class="keyword">var</span> nestMarkdowns = [];</div><div class="line">    source = source.replace(<span class="regexp">/&lt;div class="markdown"&gt;(.|\n)*&lt;\/div&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</div><div class="line">        nestMarkdowns.push(match);</div><div class="line">        <span class="keyword">return</span> <span class="string">'$&#123;nestMarkdown&#125;'</span>;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    source = source.replace(<span class="regexp">/^\n+/</span>, <span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> uselessSpaceCount = source.match(<span class="regexp">/^\s*/</span>)[<span class="number">0</span>].length;</div><div class="line">    source = source.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^ &#123;'</span> + uselessSpaceCount + <span class="string">'&#125;'</span>, <span class="string">'gm'</span>), <span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> <span class="string">'&lt;div class="markdown"&gt;'</span></div><div class="line">        + marked(source, &#123;<span class="attr">renderer</span>: renderer&#125;)</div><div class="line">            .replace(<span class="regexp">/\$&#123;nestMarkdown&#125;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> nestMarkdowns.shift();</div><div class="line">            &#125;)</div><div class="line">        + <span class="string">'&lt;/div&gt;'</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>刷一下页面，再看，符合预期，完全正常！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面一篇文章&lt;a href=&quot;/blogs/site//blogs/使用marked解析markdown.html&quot; title=&quot;使用 marked 解析 markdown&quot;&gt;使用 marked 解析 markdown&lt;/a&gt;中，大致介绍了一下 marked 使用过程中的一些问题，今天又再次遇到 ETPL 的 markdown 过滤器嵌套带来的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/markdown/"/>
    
      <category term="ETPL" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/ETPL/"/>
    
  </entry>
  
  <entry>
    <title>oracle 安装</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/oracle%E5%AE%89%E8%A3%85.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/oracle安装.html</id>
    <published>2016-05-23T04:13:00.000Z</published>
    <updated>2016-06-15T10:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。</p>
<p>本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。<br><a id="more"></a></p>
<h2 id="基本环境和工具"><a href="#基本环境和工具" class="headerlink" title="基本环境和工具"></a>基本环境和工具</h2><ul>
<li>基于 Parallels Desktop 10 的 windows 10 操作系统；</li>
<li>JDK 1.8；</li>
<li>Oracle 11g。</li>
</ul>
<p>其中， Oracle 11g 的下载地址是 <a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html" target="_blank" rel="external">win64_11gR2_database_1of2.zip</a> 、 <a href="http://www.oracle.com/technetwork/database/enterprise-edition/downloads/112010-win64soft-094461.html" target="_blank" rel="external">win64_11gR2_database_2of2.zip</a>。</p>
<h2 id="第一次安装"><a href="#第一次安装" class="headerlink" title="第一次安装"></a>第一次安装</h2><p>第一次安装，当然是处于非常的纯净的 windows 10 系统上面，基本没有任何干扰，按照安装说明一步一步往下走，很简单，很轻松，大多数参数都按照默认配置来。这样一路配置下来的话，连接 Oracle 的 URL 就会是 <code>jdbc:oracle:thin:@10.211.55.4:1521:orcl</code> （如果使用 Oracle Thin Driver 来连接的话，当然我也不知道是否还存在其他的 Driver ）。</p>
<p>后续可能会遇到一个问题：如何在一个局域网内连接这台 Oracle 服务器上面的数据库呢？默认情况下，用前面所示的 URL 并不能成功连接上，那么，首先就应该去检查连接是不是被 windows 10 的防火墙阻止了，排除了这个原因之后，再去看看 listener 服务有没有启动。</p>
<p>如果使用 PLSQL Developer 这种 GUI 工具连接 Oracle 服务器的话，会有个很蛋疼的问题，就是要关联一个 Oracle 的 client ，这玩意儿在 windows 系统下面可能要容易点，在 OS X 下面坑特别多。稍微列举一些坑：</p>
<ul>
<li>client 要分 32bit 和 64bit ，这个好像要和具体的 GUI 工具对应上？不太记得了，后续有时间补上吧！</li>
<li>在 OS X 下面要手动配置各种环境变量。</li>
</ul>
<h2 id="第二次安装（卸载重装）"><a href="#第二次安装（卸载重装）" class="headerlink" title="第二次安装（卸载重装）"></a>第二次安装（卸载重装）</h2><p>某一天，我一不小心删掉了手动创建的数据库文件（*.pdf），这下就完蛋了，不能正常工作了：数据库文件丢失。</p>
<p>网上搜了一些资料，没找到正确的处理方式，于是决定重装。</p>
<p>重装的第一步是卸载。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>很常规的，先跑到 windows 标准的应用程序卸载那里看了下，发现根本没有 Oracle ，看起来无法从这里卸载。</p>
<p>于是 Google 了一下，发现 Oracle 的卸载好麻烦：手动停服务、删文件、删注册表，这种方式肯定是逗逼方式。</p>
<p>后面鼓捣了会儿，发现“所有程序”里的 Oracle 项目下，有个 Universal Installer 工具，很多应用的安装程序和卸载程序不都是一体的么！抱着试一试的心态，点开了这个程序，果不其然，里面有卸载功能。点击“卸载”按钮，发现只能删除一些目录，果断删除，但是却不能删除主目录，必须要运行主目录下面的 deinstall/deinstall.bat 来卸载。好了，这个程序看起来只是删除目录而已，那么相关的服务可能还得自己手动删除，此处使用了 <code>sc delete serviceName</code> 命令删除服务。</p>
<p>这样鼓捣一圈下来之后，发现还有很多 Oracle 目录，感觉只能手动清除掉了。果断使用<code>鼠标右键-&gt;删除</code>的方式，结果发现被占用了，无法删除，此时可以到<code>资源监视器 -&gt; cpu 标签 -&gt; 关联的句柄</code>里面搜索，搜索关键词是文件名，然后找到哪些进程占用了文件，果断结束掉，这样一来，就可以成功删掉这些文件了。</p>
<p>这样卸载完之后，就开始安装了。</p>
<h3 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h3><p>按照第一次的安装流程来，一步一步的，比较顺利。</p>
<p>但是，在创建数据库的时候，老是说 <code>local_listener=LISTENER_ORCL</code> 这玩意儿配置错误， Goolge 了很多资料，基本都不是说的重装遇到的问题。唉，纠结了半天不知道为啥，只好跳过这个创建数据库的步骤，直接安装完成了。</p>
<p>后面仔细一想，从字面猜测应该是 listener 的名字没有和服务里面 listener 的名字对应上，抱着试一试的心态，去 /app/yibuyisheng/admin/orcl/pfile/init.ora 里面做了修改，然后运行 DBCA 重新创建数据库。事实证明，还真是这样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这是一次未知领域的探索过程，其中看似简单的每一步，都花费了不少时间，各种 Google 查资料，全方位面向搜索引擎解决问题。</li>
<li>相对于 MySQL ，Oracle 入门配置真特么麻烦。</li>
<li>做政府、国企软件项目基本要选用 Oracle 数据库，这些不懂技术的鸟人，真把程序员坑死了。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个周末学习了一些后端的技能，折腾了好久 Oracle 数据库，总算安装上了。&lt;/p&gt;
&lt;p&gt;本文记录的东西非常粗浅，仅限于探索如何使用的层面上，因此文中描述的各种观点可能有所错误，欢迎读者批评纠正。&lt;br&gt;
    
    </summary>
    
    
      <category term="Oracle" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/Oracle/"/>
    
      <category term="数据库" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>使用 marked 解析 markdown</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E4%BD%BF%E7%94%A8marked%E8%A7%A3%E6%9E%90markdown.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/使用marked解析markdown.html</id>
    <published>2016-05-20T05:49:00.000Z</published>
    <updated>2016-06-15T10:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/chjj/marked" target="_blank" rel="external">marked</a> 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。</p>
<p>最简单直接的一种使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line"><span class="built_in">console</span>.log(marked(<span class="string">'I am using __markdown__.'</span>));</div><div class="line"><span class="comment">// Outputs: &lt;p&gt;I am using &lt;strong&gt;markdown&lt;/strong&gt;.&lt;/p&gt;</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p> marked 库主要提供了一个 marked 函数，该函数声明为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">type OptionsType = &#123;</div><div class="line">    highlight: (function(code: string, lang: string, callback: function(err: Error, code: string)))=,</div><div class="line">    renderer: marked.Renderer=,</div><div class="line">    gfm: boolean=,</div><div class="line">    tables: boolean=,</div><div class="line">    breaks: boolean=,</div><div class="line">    pedantic: boolean=,</div><div class="line">    sanitize: boolean=,</div><div class="line">    smartLists: boolean=</div><div class="line">&#125;;</div><div class="line">marked(markdownString: string, options: OptionsType=, callback: Function=): string;</div></pre></td></tr></table></figure>
<p>其中，marked 可以通过 renderer 配置提供了自定义解析途径。</p>
<p>renderer 配置对应的是一个 marked.Renderer 类，此类主要包含了如下的钩子方法：</p>
<ul>
<li>code(string code, string language)</li>
<li>blockquote(string quote)</li>
<li>html(string html)</li>
<li>heading(string text, number level)</li>
<li>hr()</li>
<li>list(string body, boolean ordered)</li>
<li>listitem(string text)</li>
<li>paragraph(string text)</li>
<li>table(string header, string body)</li>
<li>tablerow(string content)</li>
<li>tablecell(string content, object flags)</li>
<li>strong(string text)</li>
<li>em(string text)</li>
<li>codespan(string code)</li>
<li>br()</li>
<li>del(string text)</li>
<li>link(string href, string title, string text)</li>
<li>image(string href, string title, string text)</li>
</ul>
<p>所有的这些方法，都可以在 renderer 实例上面覆盖掉。marked 在解析到 markdown 标记的时候，都会去调用相应的钩子方法，而钩子方法的返回结果，就会是该标记最终的解析结果。这样一来，就生成了自定义的解析结果。</p>
<p>marked 还有一个重要的配置：highlight，可以对代码块进行解析，配合相应的 css ，达到语法高亮效果。</p>
<p>以上就是 marked 最基本最核心的用法了。</p>
<p>其实本文的重点是记录在使用过程中遇到的一些坑，下面进入重点。</p>
<h1 id="markdown-缩进问题"><a href="#markdown-缩进问题" class="headerlink" title="markdown 缩进问题"></a>markdown 缩进问题</h1><p>在 markdown 的语法中，标题下面（换行之后）标记是不能缩进的，而列表项下面的标记是可以缩进的。</p>
<p>现在前端开发，经常会使用一些模板引擎，比如 <a href="https://github.com/ecomfe/etpl" target="_blank" rel="external">ETPL</a> ，这些模板，一般都会提供过滤器的功能。以 ETPL 为例，可以在 js 代码中这样添加一个过滤器：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etpl = <span class="built_in">require</span>(<span class="string">'etpl'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line">etpl.addFilter(<span class="string">'markdown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">source, useExtra</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> marked(source);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>此时在对应的模板中，就可以使用该过滤器了：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- filter: markdown() --&gt;</span></div><div class="line">    ### 标题</div><div class="line"></div><div class="line">    内容</div><div class="line">    <span class="comment">&lt;!-- /filter --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>此时，解析出来的样子会让人瞠目结舌：过滤器里面的 markdown 标记根本不会被解析掉，整个 markdown 标记块会被当成代码块。</p>
<p>为什么会这样呢？</p>
<p>如果打印一下 markdown 过滤器处理函数中的 source 参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etpl = <span class="built_in">require</span>(<span class="string">'etpl'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line">etpl.addFilter(<span class="string">'markdown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">source, useExtra</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(source);</div><div class="line">    <span class="keyword">return</span> marked(source);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以发现，打印出来的内容会是这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&quot;</div><div class="line">    ### 标题</div><div class="line"></div><div class="line">    内容</div><div class="line">    &quot;</div></pre></td></tr></table></figure>
<p>第一行没啥内容，第二行并没有顶行，而是有缩进的，然后最后一行没实际内容，只有一个缩进。</p>
<p>这明显跟 markdown 语法有冲突，必须要进行如下处理：</p>
<ul>
<li>1、第一行和最后一行没啥实际内容，可以去掉；</li>
<li>2、检测第一行前面的缩进空格数（这里假定缩进用的是空格），记录下来，假设为 <code>n</code> ；</li>
<li>3、将每一行前面的 <code>n</code> 个空格去掉。</li>
</ul>
<p>具体的代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> etpl = <span class="built_in">require</span>(<span class="string">'etpl'</span>);</div><div class="line"><span class="keyword">var</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>);</div><div class="line">etpl.addFilter(<span class="string">'markdown'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">source, useExtra</span>) </span>&#123;</div><div class="line">    source = source.replace(<span class="regexp">/(^\n+|\n+$)/g</span>, <span class="string">''</span>);</div><div class="line">    <span class="keyword">var</span> uselessSpaceCount = source.match(<span class="regexp">/^\s*/</span>)[<span class="number">0</span>].length;</div><div class="line">    source = source.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^ &#123;'</span> + uselessSpaceCount + <span class="string">'&#125;'</span>, <span class="string">'gm'</span>), <span class="string">''</span>);</div><div class="line">    <span class="keyword">return</span> marked(source);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="HTML-标签"><a href="#HTML-标签" class="headerlink" title="HTML 标签"></a>HTML 标签</h1><p>有的时候，可能想给 markdown 标记的某一块加上背景色，比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- filter: markdown() --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background-red"</span>&gt;</span></div><div class="line">### 标题</div><div class="line"></div><div class="line">内容</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- /filter --&gt;</span></div></pre></td></tr></table></figure>
<p>这样写又会崩溃了， div 内部的 markdown 标记并不会被解析！</p>
<p>解决方法就是把 div 放过滤器外边吧：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"background-red"</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- filter: markdown() --&gt;</span></div><div class="line">### 标题</div><div class="line"></div><div class="line">内容</div><div class="line"><span class="comment">&lt;!-- /filter --&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/chjj/marked&quot;&gt;marked&lt;/a&gt; 是一个解析 markdown 的 JavaScript 库，可以运行在 Node 环境或者浏览器环境。&lt;/p&gt;
&lt;p&gt;最简单直接的一种使用方式：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; marked = &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;marked&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(marked(&lt;span class=&quot;string&quot;&gt;&#39;I am using __markdown__.&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Outputs: &amp;lt;p&amp;gt;I am using &amp;lt;strong&amp;gt;markdown&amp;lt;/strong&amp;gt;.&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="markdown" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/markdown/"/>
    
      <category term="ETPL" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/ETPL/"/>
    
  </entry>
  
  <entry>
    <title>实现第一个 vscode 扩展</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%20vscode%20%E6%89%A9%E5%B1%95.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/实现第一个 vscode 扩展.html</id>
    <published>2016-01-10T10:20:00.000Z</published>
    <updated>2016-06-15T10:47:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>提前声明：<br><br>此处使用的 vscode 版本是0.10.6</p>
</blockquote>
<p>vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。</p>
<p>个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。<br><a id="more"></a></p>
<p>但是我个人很看重 vscode 的这些点：</p>
<ul>
<li>1、虽然使用 Electron ，但是代码各方面处理还是挺快的，特别是打开比较大的 js 文件，基本不会挂掉，性能堪比 sublime ；</li>
<li>2、里面全是 js 系列的东西（虽然加了一层 ts ），对于前端来说，很是亲切，如果成熟到一定程度的话，将会有大把的前端程序员参与插件的开发。相比于 sublime 使用 python ， vscode 真是太爽了，深度定制的时候少了语言的门槛。</li>
</ul>
<p>目前个人感觉的小缺点有：</p>
<ul>
<li>1、无法代码折叠；</li>
<li>2、扩展 API 还不完善，有些比较酷的功能依据现有 API 还无法实现。</li>
</ul>
<p>废话不对说，走一个插件先。</p>
<h3 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h3><p>对 JavaScript 代码进行检查，基于的检查规则是 <code>fecs</code> 。</p>
<h3 id="安装必要的东西"><a href="#安装必要的东西" class="headerlink" title="安装必要的东西"></a>安装必要的东西</h3><blockquote>
<p>npm install -g yo generator-code</p>
</blockquote>
<h3 id="生成扩展项目"><a href="#生成扩展项目" class="headerlink" title="生成扩展项目"></a>生成扩展项目</h3><p>执行下面的代码：</p>
<blockquote>
<p>yo code</p>
</blockquote>
<p>然后会出现这样的选择界面：</p>
<p><img src="https://github.com/yibuyisheng/blogs/blob/master/imgs/13.png?raw=true" alt=""></p>
<p>选择：</p>
<blockquote>
<p>New Extension (JavaScript)</p>
</blockquote>
<p>这样就会生成使用 JavaScript 进行插件开发的项目结构。</p>
<p>后续还会设置扩展的名字（此处设为 test ）、扩展的唯一标识、扩展的描述、扩展的发布者名字、是否初始化为 Git 仓库。根据提示做相应设置就好了。设置完之后就会自动运行 <code>npm install</code> ，安装好 vscode 模块。</p>
<p>一切结束之后，你会发现在当前目录下生成了一个叫 <code>test</code> 的目录，进入这个目录，下面就有了一堆文件。</p>
<h3 id="修改-package-json-文件"><a href="#修改-package-json-文件" class="headerlink" title="修改 package.json 文件"></a>修改 package.json 文件</h3><p>更改 <code>activationEvents</code> 配置项，设为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    <span class="string">"onLanguage:javascript"</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>意思就是在打开 JavaScript 文件的时候会激活这个扩展。</p>
<p>删掉 <code>contributes</code> 配置项，此处用不上这个配置。</p>
<h3 id="修改-extension-js-文件"><a href="#修改-extension-js-文件" class="headerlink" title="修改 extension.js 文件"></a>修改 extension.js 文件</h3><p>这个文件是 package.json 里面 <code>main</code> 配置指向的文件，扩展激活的时候会调用这个文件提供的 activate 方法。</p>
<p>对于该扩展，其执行流程为：</p>
<ul>
<li>1、在用户打开 js 文件的时候激活扩展，注册好文件保存的回调方法；</li>
<li>2、在用户保存文件的时候，执行 fecs 检查；</li>
<li>3、将第二步中检查出的错误和警告等信息显示到编辑器中。</li>
</ul>
<h4 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h4><p>在开发扩展的时候，要使用到 <code>vscode</code> 和 <code>fecs</code> 两个模块：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> vscode = <span class="built_in">require</span>(<span class="string">'vscode'</span>);</div><div class="line"><span class="keyword">var</span> fecs = <span class="built_in">require</span>(<span class="string">'fecs'</span>);</div></pre></td></tr></table></figure>
<p>然后注册文件保存的回调函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> disposable = vscode.workspace.onDidSaveTextDocument(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="comment">// do something while saving</span></div><div class="line">&#125;);</div><div class="line">context.subscriptions.push(diagnosticCollection);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong><br><br>此处 <code>onDidSaveTextDocument</code> 返回了一个 disposable 对象，这个对象有一个 <code>dispose</code> 方法，在扩展销毁的时候，会调用这个方法。因此，这个对象要事先放到 <code>context.subscriptions</code> ，<code>context</code> 是 <code>activate</code> 方法调用的时候传入的上下文对象。</p>
</blockquote>
<p>在这个回调函数里面就可以执行 fecs 检查了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">fecs.check(</div><div class="line">    &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">'js'</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">'FECS JS'</span>,</div><div class="line">        <span class="attr">_</span>: [event.uri.path],</div><div class="line">        <span class="attr">stream</span>: <span class="literal">false</span></div><div class="line">    &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">hasNoError, errors</span>) </span>&#123;</div><div class="line">        <span class="comment">// the result of check</span></div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p><code>hasNoError</code> 和 <code>errors</code> 表明了检查结果。此处可以忽略 <code>hasNoError</code> ，直接将 errors 转换成 vscode 能够展示的错误。</p>
<p>vscode 提供了 <code>DiagnosticCollection</code> ，用于向界面上展示错误信息。那么如何操作呢？</p>
<p>首先要拿到一个 <code>DiagnosticCollection</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class="string">'fecs'</span>);</div></pre></td></tr></table></figure>
<p>然后往这个对象里面塞错误信息：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diagnosticCollection.set(someErrorObject);</div></pre></td></tr></table></figure>
<h4 id="整合所有代码之后的样子"><a href="#整合所有代码之后的样子" class="headerlink" title="整合所有代码之后的样子"></a>整合所有代码之后的样子</h4><p>整个 <code>extension.js</code> 的代码整合起来如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">var</span> vscode = <span class="built_in">require</span>(<span class="string">'vscode'</span>);</div><div class="line"><span class="keyword">var</span> fecs = <span class="built_in">require</span>(<span class="string">'fecs'</span>);</div><div class="line"></div><div class="line">fecs.leadName = <span class="string">'fecs'</span>;</div><div class="line"></div><div class="line">exports.activate = <span class="function"><span class="keyword">function</span> <span class="title">activate</span>(<span class="params">context</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> diagnosticCollection = vscode.languages.createDiagnosticCollection(<span class="string">'fecs'</span>);</div><div class="line">    context.subscriptions.push(diagnosticCollection);</div><div class="line"></div><div class="line">    vscode.workspace.onDidSaveTextDocument(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">        diagnosticCollection.clear();</div><div class="line">        fecs.check(</div><div class="line">            &#123;</div><div class="line">                <span class="attr">type</span>: <span class="string">'js'</span>,</div><div class="line">                <span class="attr">name</span>: <span class="string">'FECS JS'</span>,</div><div class="line">                <span class="attr">_</span>: [event.uri.path],</div><div class="line">                <span class="attr">stream</span>: <span class="literal">false</span></div><div class="line">            &#125;,</div><div class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">hasNoError, errors</span>) </span>&#123;</div><div class="line">                diagnosticCollection.set(convertErrors(errors));</div><div class="line">            &#125;</div><div class="line">        );</div><div class="line">    &#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertErrors</span>(<span class="params">fecsErrors</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fecsErrors.map(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> [</div><div class="line">            vscode.Uri.file(error.path),</div><div class="line">            error.errors.map(<span class="function"><span class="keyword">function</span> (<span class="params">fileError</span>) </span>&#123;</div><div class="line">                <span class="comment">// fecs的行号和列号与vscode有差异。。。。</span></div><div class="line">                <span class="keyword">var</span> line = fileError.line - <span class="number">1</span>;</div><div class="line">                <span class="keyword">var</span> column = fileError.column - <span class="number">1</span>;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> <span class="keyword">new</span> vscode.Diagnostic(</div><div class="line">                    <span class="keyword">new</span> vscode.Range(line, column, line, column + <span class="number">1</span>),</div><div class="line">                    <span class="string">`[FECS]: <span class="subst">$&#123;fileError.message&#125;</span>  (<span class="subst">$&#123;fileError.rule&#125;</span>)`</span>,</div><div class="line">                    &#123;</div><div class="line">                        <span class="number">1</span>: vscode.DiagnosticSeverity.Warning,</div><div class="line">                        <span class="number">2</span>: vscode.DiagnosticSeverity.Error</div><div class="line">                    &#125;[fileError.severity]</div><div class="line">                );</div><div class="line">            &#125;)</div><div class="line">        ];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注：</strong> <a href="http://fecs.baidu.com/" target="_blank" rel="external">fecs 是什么？</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;提前声明：&lt;br&gt;&lt;br&gt;此处使用的 vscode 版本是0.10.6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vscode 是微软最近弄出来的代码编辑器，基于 Electron ，对于前端程序员来说，颇亲切。&lt;/p&gt;
&lt;p&gt;个人觉得，到目前这个版本为止， vscode 还不是很成熟，总体体验上离 sublime 还有一定差距。&lt;br&gt;
    
    </summary>
    
    
      <category term="vscode" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>爬虫与编码</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E7%88%AC%E8%99%AB%E4%B8%8E%E7%BC%96%E7%A0%81.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/爬虫与编码.html</id>
    <published>2016-01-09T05:23:00.000Z</published>
    <updated>2016-06-08T09:52:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。<br><a id="more"></a></p>
<p>其实，爬一个网站的数据也是爬取者和被爬取者的一种攻防较量：一般情况下，被爬取者总是会想方设法地阻止爬取者爬取自家网站数据。</p>
<p>于是，一些网站就会采取一些措施来阻止非正常访问：</p>
<ul>
<li>某某关键接口只能每分钟调用若干次；</li>
<li>某某 IP 访问网站太频繁，直接拒绝掉该 IP 发过来的请求。</li>
</ul>
<p>当然，这些措施都只是治标不治本，不能从根本上杜绝自己网站数据被爬。</p>
<p>从爬取者的角度来看，要突破层层限制，拿到目标网站的数据，还是要做一些事情的：</p>
<ul>
<li>如果要爬取的目标网页需要登录才能访问到，那么可以采用 phantomjs 来简化掉 session 的处理；</li>
<li>在爬取的过程中，如果发现服务器从某个时刻开始一直拒绝掉自己的请求，那么就要怀疑自己的 IP 是否被屏蔽掉了，或者某个接口是否访问太频繁了；</li>
<li>对于有 IP 限制策略的网站，尽量模拟正常用户访问，频率不要太快，最好做多个节点来爬取。</li>
</ul>
<p><strong>等等，有点偏题了！下面进入正轨：</strong></p>
<p>在初次写爬虫代码的时候，很容易遇到解析出来的数据是乱码的问题：</p>
<p><img src="https://github.com/yibuyisheng/blogs/blob/master/imgs/12.png?raw=true" alt=""></p>
<p>面对这些乱码，如何解决呢？</p>
<h3 id="注意-HTTP-响应的头部"><a href="#注意-HTTP-响应的头部" class="headerlink" title="注意 HTTP 响应的头部"></a>注意 HTTP 响应的头部</h3><p>留意一下 HTTP 响应的头部是否有用 gzip 压缩过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Encoding:gzip</div></pre></td></tr></table></figure>
<p>如果有这种字眼，那么响应正文部分就是使用 gzip 压缩过的，在拿到这种压缩过的数据之后，要先解压。</p>
<p>Node.js 中，提供了 zlib 模块，用于处理 gzip 相关的操作。对于解压 gzip ，可以这样做：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `res` 是响应对象，http.IncommingMessage 类型的</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> buffers = [];<span class="comment">// 暂存 gzip 解压过后的 buffer</span></div><div class="line"><span class="keyword">var</span> size = <span class="number">0</span>;<span class="comment">// 记录整个响应体解压后的数据大小</span></div><div class="line"><span class="keyword">var</span> gunzipStream = zlib.createGunzip();</div><div class="line">res.pipe(gunzipStream);</div><div class="line">gunzipStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">buffer</span>) </span>&#123;</div><div class="line">    buffers.push(buffer);</div><div class="line">    size += buffer.length;</div><div class="line">&#125;);</div><div class="line">gunzipStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="comment">// 发生了错误，处理下吧！</span></div><div class="line">&#125;);</div><div class="line">gunzipStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> unzipedBuffer = Buffer.concat(buffers, size); <span class="comment">// unzipedBuffer 就是解压过后的数据</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="注意文本编码"><a href="#注意文本编码" class="headerlink" title="注意文本编码"></a>注意文本编码</h3><p>拿着最终 gzip 解压出来的数据，开心的去进行后续处理，结果继续乱码，为什么会这样？</p>
<p>Node.js 里面默认字符串是 <code>utf-8</code> 编码的，如果 gzip 解压出来的数据不是 <code>utf-8</code> 编码的话，那么把这堆 buffer 数据转换成字符串的时候就可能产生乱码。 到目前为止，Node.js 内置支持的解码方式很有限，只能依靠一些第三方模块进行某些文本解码。</p>
<p>怎么办呢？</p>
<p>留意一下响应头当中的 <code>Content-Type</code> 部分，如果 charset 是非 <code>utf-8</code> 的话，那就要考虑继续对数据进行解码了。</p>
<p>对于中文网站，可能会使用 <code>GBK</code> 或者 <code>GB2312</code> 进行编码，对于此种场景，需要用到第三方的解码工具，此处选用了 <code>iconv-lite</code> 。解码过程如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> finallyResponseText = <span class="built_in">require</span>(<span class="string">'iconv-lite'</span>).decode(unzipedBuffer, <span class="string">'gbk'</span>);</div></pre></td></tr></table></figure>
<p>这样，就拿到了最终想要的文本数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名 web 开发人员，时不时爬爬别人家的网站还是很有趣的。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6 简单特性概览</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/ES6%20%E7%AE%80%E5%8D%95%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/ES6 简单特性概览.html</id>
    <published>2015-10-18T03:43:00.000Z</published>
    <updated>2016-07-01T03:56:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容：</p>
<ul>
<li>讲解了如何使用交互式的方式体验 ES6 。</li>
<li>列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。</li>
</ul>
<a id="more"></a>
<h2 id="体验-ECMAScript-6"><a href="#体验-ECMAScript-6" class="headerlink" title="体验 ECMAScript 6"></a>体验 ECMAScript 6</h2><p>有三种简单的方式可以运行 ES6 代码：</p>
<ul>
<li>1、 Web 浏览器：使用<a href="http://babeljs.io/repl/" target="_blank" rel="external">在线的 Babel REPL </a>，这是一个交互式的工具，将 ES6 代码编译成 ES5 代码。采用这种方式的话就不用安装任何东西。</li>
<li>2、命令行：使用 <code>babel-node</code> ，一个 Node.js 可执行程序的版本，认识 ES6 代码（在内部会编译成 ES5 代码）。可以通过 npm 安装。</li>
<li>3、各种 JavaScript 引擎：查询<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external"> kangax 的 ES6 兼容表格</a>，可以找到本地支持 ES6 的引擎。</li>
</ul>
<p>下面将会给出更多关于选项1和2的内容。</p>
<h3 id="Babel-REPL"><a href="#Babel-REPL" class="headerlink" title="Babel REPL"></a>Babel REPL</h3><p>Babel REPL 有四个主要部分：</p>
<ul>
<li>左上角部分包含 ES6 源码。</li>
<li>左下角部分显示 ES6 代码中发现的语法错误。</li>
<li>右上角部分包含 ES6 代码编译成的 ES5 代码。</li>
<li>右下角部分展示通过 <code>console.log()</code> 输出的内容。</li>
</ul>
<p><img src="../images/11.jpg" alt=""></p>
<h3 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h3><p><code>babel-node</code> 可执行程序可以通过 npm 安装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --global babel</div></pre></td></tr></table></figure>
<p>你可以像使用可执行程序 <code>node</code> 一样使用 <code>babel-node</code> 。类似于 <code>node</code> ，像这样启动一个交互式的 REPL ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">babel-node</div></pre></td></tr></table></figure>
<p>一旦进入该 REPL ，你就可以执行 ES6 代码了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; let arr = [1, 2, 3];</div><div class="line">&gt; arr.map(x =&gt; x * x)</div><div class="line">[ 1, 4, 9 ]</div></pre></td></tr></table></figure>
<p>注意 <a href="https://github.com/babel/babel/issues/1741" target="_blank" rel="external">babel-node 目前还不支持多行输入</a>。</p>
<p>Babel 官网有<a href="http://babeljs.io/docs/usage/cli/" target="_blank" rel="external">更多关于 Babel 命令行工具的信息</a>。</p>
<p>本文接下来的部分描述了易于接受的 ES6 特性。</p>
<h2 id="从-var-到-let-const"><a href="#从-var-到-let-const" class="headerlink" title="从 var 到 let/const"></a>从 var 到 let/const</h2><p>ES6 有两种新的声明变量的方式：</p>
<ul>
<li><code>let</code> （大致）相当于 <code>var</code> 的一个块级范围版本。</li>
<li><code>const</code> 类似于 <code>let</code> ，但是用于创建<em>常量</em>：值不能被改变的变量。</li>
</ul>
<p>一般情况下，你可以用 <code>let</code> 或者 <code>const</code> 替换每一个 <code>var</code> 。但是不能盲目地这么做，因为不同类型的变量作用范围可能会改变代码的运行流程。看下面的用 ES5 写的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">randomize</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (randomize) &#123;</div><div class="line">        <span class="keyword">var</span> x = <span class="built_in">Math</span>.random(); <span class="comment">// (A) scope: whole function</span></div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x; <span class="comment">// accesses the x from line A</span></div><div class="line">&#125;</div><div class="line">func(<span class="literal">false</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p><code>func()</code> 返回 <code>undefined</code> ，这可能会比较奇怪。如果重写一下这段代码，让其更清楚地展现出来实际上发生了什么，你就明白了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">randomize</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x;</div><div class="line">    <span class="keyword">if</span> (randomize) &#123;</div><div class="line">        x = <span class="built_in">Math</span>.random();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line">func(<span class="literal">false</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>如果你在最初的版本中用 <code>let</code> 替换 <code>var</code> ，将会得到不一样的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">randomize</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (randomize) &#123;</div><div class="line">        <span class="keyword">let</span> x = <span class="built_in">Math</span>.random();</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">&#125;</div><div class="line">func(<span class="literal">false</span>); <span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>因此，盲目地用 <code>let</code> 或者 <code>const</code> 替换 <code>var</code> 很危险。我的建议是：</p>
<ul>
<li>仅在新的代码中使用 <code>let</code>/<code>const</code> 。</li>
<li>不动老的代码，或者小心地重构老的代码。</li>
</ul>
<h2 id="从-IIFE-到块级作用域"><a href="#从-IIFE-到块级作用域" class="headerlink" title="从 IIFE 到块级作用域"></a>从 IIFE 到块级作用域</h2><p>在 ES5 中，你必须使用 IIFE 来使变量保持本地化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;  <span class="comment">// open IIFE</span></div><div class="line">    <span class="keyword">var</span> tmp = ···;</div><div class="line">    ···</div><div class="line">&#125;());  <span class="comment">// close IIFE</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
<p>在 ECMAScript 6 中，你可以简单地使用一个块和一个 <code>let</code> 声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;  <span class="comment">// open block</span></div><div class="line">    <span class="keyword">let</span> tmp = ···;</div><div class="line">    ···</div><div class="line">&#125;  <span class="comment">// close block</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure>
<h2 id="从拼接字符串到模板字面量"><a href="#从拼接字符串到模板字面量" class="headerlink" title="从拼接字符串到模板字面量"></a>从拼接字符串到模板字面量</h2><p>在 ES6 中， JavaScript 终于拥有了字面量式的字符串插值和多行字符串功能。</p>
<h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><p>在 ES5 中，通过拼接字符串片段和变量值的方式来把变量值插入到字符串中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCoord</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'('</span>+x+<span class="string">', '</span>+y+<span class="string">')'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以通过模板字面量的方式实现字符串插值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCoord</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`(<span class="subst">$&#123;x&#125;</span>, <span class="subst">$&#123;y&#125;</span>)`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>模板字面量也可以用于表示多行字符串。</p>
<p>例如，下面是在 ES5 中表示多行文本的样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HTML5_SKELETON =</div><div class="line">    <span class="string">'&lt;!doctype html&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;html&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;head&gt;\n'</span> +</div><div class="line">    <span class="string">'    &lt;meta charset="UTF-8"&gt;\n'</span> +</div><div class="line">    <span class="string">'    &lt;title&gt;&lt;/title&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;/head&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;body&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;/body&gt;\n'</span> +</div><div class="line">    <span class="string">'&lt;/html&gt;\n'</span>;</div></pre></td></tr></table></figure>
<p>如果你通过反斜线转义换行符，代码看起来就漂亮一点了（但是仍然需要显示地添加新行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> HTML5_SKELETON = <span class="string">'\</span></div><div class="line">    &lt;!doctype html&gt;\n\</div><div class="line">    &lt;html&gt;\n\</div><div class="line">    &lt;head&gt;\n\</div><div class="line">        &lt;meta charset="UTF-8"&gt;\n\</div><div class="line">        &lt;title&gt;&lt;/title&gt;\n\</div><div class="line">    &lt;/head&gt;\n\</div><div class="line">    &lt;body&gt;\n\</div><div class="line">    &lt;/body&gt;\n\</div><div class="line">    &lt;/html&gt;';</div></pre></td></tr></table></figure>
<p>ES6 模板字面量可以跨越多行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> HTML5_SKELETON = <span class="string">`</span></div><div class="line">    &lt;!doctype html&gt;</div><div class="line">    &lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset="UTF-8"&gt;</div><div class="line">        &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">    &lt;/html&gt;`;</div></pre></td></tr></table></figure>
<p>（这些例子包含的空格数是不一样的，但是在此处并不重要。）</p>
<h2 id="从函数表达式到箭头函数"><a href="#从函数表达式到箭头函数" class="headerlink" title="从函数表达式到箭头函数"></a>从函数表达式到箭头函数</h2><p>在当前的 ES5 代码中，在函数表达式中必须小心使用 <code>this</code> 。在下面的例子中，我创建了辅助变量 <code>_this</code> （行 A ），以便在行 B 能够访问到 UiComponent 的 <code>this</code> 。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">UiComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>; <span class="comment">// (A)</span></div><div class="line">    <span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</div><div class="line">    button.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">'CLICK'</span>);</div><div class="line">        _this.handleClick(); <span class="comment">// (B)</span></div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">UiComponent.prototype.handleClick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    ···</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以使用箭头函数，它不会改变 <code>this</code> 指向（行 A ，<em>词法范围的 this</em> ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UiComponent</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>() &#123;</div><div class="line">        <span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">'myButton'</span>);</div><div class="line">        button.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'CLICK'</span>);</div><div class="line">            <span class="keyword">this</span>.handleClick(); <span class="comment">// (A)</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    handleClick() &#123;</div><div class="line">        ···</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>箭头函数对于短小的仅返回表达式值的回调函数来说尤其方便。</p>
<p>在 ES5 中，这样的回调函数相当啰嗦：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> squares = arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;);</div></pre></td></tr></table></figure>
<p>在 ES6 中，箭头函数简洁很多：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> squares = arr.map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div></pre></td></tr></table></figure>
<p>在定义参数的时候，如果参数是一个标识符，甚至可以省略括号。所以： <code>(x) =&gt; x * x</code> 和 <code>x =&gt; x * x</code> 都是合法的。</p>
<h2 id="处理多个返回值"><a href="#处理多个返回值" class="headerlink" title="处理多个返回值"></a>处理多个返回值</h2><p>一些函数或者方法通过数组或对象返回多个值。在 ES5 中，如果想要访问这些值，总是需要创建一些中间变量。在 ES6 中，可以借助于解构来避免中间变量。</p>
<h3 id="借助数组返回多个值"><a href="#借助数组返回多个值" class="headerlink" title="借助数组返回多个值"></a>借助数组返回多个值</h3><p><code>exec()</code> 通过类数组对象返回捕获到的匹配组。在 ES5 中，需要一个中间变量（下面例子中的 <code>matchObj</code> ），即便是你仅对匹配组感兴趣：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> matchObj =</div><div class="line">    <span class="regexp">/^(\d\d\d\d)-(\d\d)-(\d\d)$/</span></div><div class="line">    .exec(<span class="string">'2999-12-31'</span>);</div><div class="line"><span class="keyword">var</span> year = matchObj[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> month = matchObj[<span class="number">2</span>];</div><div class="line"><span class="keyword">var</span> day = matchObj[<span class="number">3</span>];</div></pre></td></tr></table></figure>
<p>在 ES6 中，解构使代码更简单：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [, year, month, day] =</div><div class="line">    <span class="regexp">/^(\d\d\d\d)-(\d\d)-(\d\d)$/</span></div><div class="line">    .exec(<span class="string">'2999-12-31'</span>);</div></pre></td></tr></table></figure>
<p>左侧数组模式开始处为空，可以跳过右侧索引为0的数组元素。</p>
<h3 id="借助对象返回多个值"><a href="#借助对象返回多个值" class="headerlink" title="借助对象返回多个值"></a>借助对象返回多个值</h3><p>方法 <code>Object.getOwnPropertyDescriptor()</code> 返回一个<em>属性描述符</em>，一个包含多个属性值的对象。</p>
<p>在 ES5 中，即便你仅对一个对象的属性感兴趣，仍然需要一个中间变量（下例中的 <code>propDesc</code> ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> propDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"><span class="keyword">var</span> writable = propDesc.writable;</div><div class="line"><span class="keyword">var</span> configurable = propDesc.configurable;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(writable, configurable); <span class="comment">// true true</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，可以使用解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;writable, configurable&#125; =</div><div class="line">    <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(writable, configurable); <span class="comment">// true true</span></div></pre></td></tr></table></figure>
<p><code>{writable, configurable}</code> 是下面内容的缩写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="attr">writable</span>: writable, <span class="attr">configurable</span>: configurable &#125;</div></pre></td></tr></table></figure>
<h2 id="从-for-到-forEach-，再到-for-of"><a href="#从-for-到-forEach-，再到-for-of" class="headerlink" title="从 for 到 forEach() ，再到 for-of"></a>从 for 到 forEach() ，再到 for-of</h2><p>在 ES5 之前，可以选择使用数组方法 <code>forEach()</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><code>for</code> 循环的优点在于可以中断， <code>forEach()</code> 的优点在于简洁。</p>
<p>在 ES6 中， <code>for-of</code> 循环结合了两种优点：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> arr) &#123;</div><div class="line">    <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果想访问每个元素的索引和值， <code>for-of</code> 也可以做到，通过新的数组方法 <code>entries()</code> 和解构：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> arr.entries()) &#123;</div><div class="line">    <span class="built_in">console</span>.log(index+<span class="string">'. '</span>+elem);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="处理参数默认值"><a href="#处理参数默认值" class="headerlink" title="处理参数默认值"></a>处理参数默认值</h2><p>在 ES5 中，为参数指定默认值的代码像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    x = x || <span class="number">0</span>;</div><div class="line">    y = y || <span class="number">0</span>;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6 有更漂亮的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x=<span class="number">0</span>, y=<span class="number">0</span></span>) </span>&#123;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个额外的好处就是，在 ES6 中，参数默认值只会被 <code>undefined</code> 触发，而在之前的 ES5 代码中，任何假值都会出发默认值。</p>
<h2 id="处理命名参数"><a href="#处理命名参数" class="headerlink" title="处理命名参数"></a>处理命名参数</h2><p>在 JavaScript 中使用命名参数的一种通常做法是通过对象字面量的方式（所谓的<em>可选对象模式</em>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">selectEntries(&#123; <span class="attr">start</span>: <span class="number">0</span>, <span class="attr">end</span>: <span class="number">-1</span> &#125;);</div></pre></td></tr></table></figure>
<p>这种方式的两个优点是：代码可读性更好，并且可以更容易地省略任何参数。</p>
<p>在 ES5 中，你可以这样实现 <code>selectEntries()</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectEntries</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> start = options.start || <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> end = options.end || <span class="number">-1</span>;</div><div class="line">    <span class="keyword">var</span> step = options.step || <span class="number">1</span>;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，你可以在参数定义中使用解构，代码看起来就更简单了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectEntries</span>(<span class="params">&#123; start=<span class="number">0</span>, end=<span class="number">-1</span>, step=<span class="number">1</span> &#125;</span>) </span>&#123;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>在 ES5 中，要让参数 <code>options</code> 变得可选，会添加行 A 所示的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectEntries</span>(<span class="params">options</span>) </span>&#123;</div><div class="line">    options = options || &#123;&#125;; <span class="comment">// (A)</span></div><div class="line">    <span class="keyword">var</span> start = options.start || <span class="number">0</span>;</div><div class="line">    <span class="keyword">var</span> end = options.end || <span class="number">-1</span>;</div><div class="line">    <span class="keyword">var</span> step = options.step || <span class="number">1</span>;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，可以用 <code>{}</code> 指定参数的默认值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectEntries</span>(<span class="params">&#123; start=<span class="number">0</span>, end=<span class="number">-1</span>, step=<span class="number">1</span> &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="从-arguments-到剩余参数"><a href="#从-arguments-到剩余参数" class="headerlink" title="从 arguments 到剩余参数"></a>从 arguments 到剩余参数</h2><p>在 ES5 中，如果想要函数（或者方法）接收任意数量的参数，就必须使用特殊变量 <code>arguments</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logAllArguments</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，可以通过 <code>...</code> 操作符声明一个剩余参数（下例中的 args ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logAllArguments</span>(<span class="params">...args</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg <span class="keyword">of</span> args) &#123;</div><div class="line">        <span class="built_in">console</span>.log(arg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果仅对尾部的参数感兴趣，剩余参数看起来就更漂亮了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">pattern, ...args</span>) </span>&#123;</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES5 中处理这种场景很笨拙：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pattern = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>.slice(<span class="number">1</span>);</div><div class="line">    ···</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>剩余参数让代码可读性更好：你可以从参数定义上面看出来一个函数是否有不定数量的参数。</p>
<h2 id="从-apply-到扩展操作符（-…-）"><a href="#从-apply-到扩展操作符（-…-）" class="headerlink" title="从 apply() 到扩展操作符（ … ）"></a>从 apply() 到扩展操作符（ … ）</h2><p>在 ES5 中，用 <code>apply()</code> 将数组转换成参数。 ES6 有扩展操作符可以达到这个目的。</p>
<h3 id="4-11-1-Math-max"><a href="#4-11-1-Math-max" class="headerlink" title="4.11.1 Math.max()"></a>4.11.1 Math.max()</h3><p>ES5 - apply() ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; Math.max.apply(null, [-1, 5, 11, 3])</div><div class="line">11</div></pre></td></tr></table></figure>
<p>ES6 - 扩展操作符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; Math.max(...[-1, 5, 11, 3])</div><div class="line">11</div></pre></td></tr></table></figure>
<h3 id="Array-prototype-push"><a href="#Array-prototype-push" class="headerlink" title="Array.prototype.push()"></a>Array.prototype.push()</h3><p>ES5 - apply() ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</div><div class="line"></div><div class="line">arr1.push.apply(arr1, arr2);</div><div class="line">    <span class="comment">// arr1 is now ['a', 'b', 'c', 'd']</span></div></pre></td></tr></table></figure>
<p>ES6 - 扩展操作符：</p>
<p>let arr1 = [‘a’, ‘b’];<br>let arr2 = [‘c’, ‘d’];</p>
<p>arr1.push(…arr2);<br>    // arr1 is now [‘a’, ‘b’, ‘c’, ‘d’]</p>
<h2 id="从-concat-到扩展操作符（-…-）"><a href="#从-concat-到扩展操作符（-…-）" class="headerlink" title="从 concat() 到扩展操作符（ … ）"></a>从 concat() 到扩展操作符（ … ）</h2><p>扩展操作符也能将操作数的内容转换成数组元素，也就是说它实现数组方法 <code>concat()</code> 的功能。</p>
<p>ES5 - concat() ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">var</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(arr1.concat(arr2, arr3));</div><div class="line">    <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<p>ES6 - 扩展操作符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</div><div class="line"><span class="keyword">let</span> arr2 = [<span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log([...arr1, ...arr2, ...arr3]);</div><div class="line">    <span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></div></pre></td></tr></table></figure>
<h2 id="从构造函数到类"><a href="#从构造函数到类" class="headerlink" title="从构造函数到类"></a>从构造函数到类</h2><p>相对于构造函数来说，ES6 类是一种更加方便的语法。</p>
<h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><p>在 ES5 中，直接实现构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line">Person.prototype.describe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'Person called '</span>+<span class="keyword">this</span>.name;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在 ES6 中，类为构造函数提供了略微方便的语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    describe() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">'Person called '</span>+<span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="继承类"><a href="#继承类" class="headerlink" title="继承类"></a>继承类</h3><p>在 ES5 中实现子类很复杂，尤其是要指向父类构造函数和父类属性。下面是一种比较正规的创建 <code>Person</code> 的子构造器 <code>Employee</code> 的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Employee</span>(<span class="params">name, title</span>) </span>&#123;</div><div class="line">    Person.call(<span class="keyword">this</span>, name); <span class="comment">// super(name)</span></div><div class="line">    <span class="keyword">this</span>.title = title;</div><div class="line">&#125;</div><div class="line">Employee.prototype = <span class="built_in">Object</span>.create(Person.prototype);</div><div class="line">Employee.prototype.constructor = Employee;</div><div class="line">Employee.prototype.describe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> Person.prototype.describe.call(<span class="keyword">this</span>) <span class="comment">// super.describe()</span></div><div class="line">           + <span class="string">' ('</span> + <span class="keyword">this</span>.title + <span class="string">')'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>ES6 内置支持子类继承，使用 extends 子句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(name, title) &#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.title = title;</div><div class="line">    &#125;</div><div class="line">    describe() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.describe() + <span class="string">' ('</span> + <span class="keyword">this</span>.title + <span class="string">')'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="从自定义错误构造函数到-Error-子类"><a href="#从自定义错误构造函数到-Error-子类" class="headerlink" title="从自定义错误构造函数到 Error 子类"></a>从自定义错误构造函数到 Error 子类</h2><p>在 ES5 中，不可能内置构造器的继承（除了 Error ）。下面的代码展示了一种继承的方式，并赋予了构造函数 MyError 一些重要的特性，比如堆栈跟踪：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyError</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// Use Error as a function</span></div><div class="line">    <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</div><div class="line">    copyOwnPropertiesFrom(<span class="keyword">this</span>, superInstance);</div><div class="line">&#125;</div><div class="line">MyError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</div><div class="line">MyError.prototype.constructor = MyError;</div></pre></td></tr></table></figure>
<p>在 ES6 中，所有内置的构造函数都可以被继承，这就是为什么下面的代码实现了在 ES5 中只能模拟的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span> <span class="keyword">extends</span> <span class="title">Error</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="从对象字面量中的函数表达式到方法定义"><a href="#从对象字面量中的函数表达式到方法定义" class="headerlink" title="从对象字面量中的函数表达式到方法定义"></a>从对象字面量中的函数表达式到方法定义</h2><p>在 JavaScript 中，方法就是值为函数的属性。</p>
<p>在 ES5 对象字面量中，方法以类似于其他属性的方式创建。属性值通过函数表达式提供。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        ···</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.foo();</div><div class="line">    &#125;, <span class="comment">// trailing comma is legal in ES5</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ES6 有<em>方法定义</em>，一种创建方法的特殊语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    foo() &#123;</div><div class="line">        ···</div><div class="line">    &#125;,</div><div class="line">    bar() &#123;</div><div class="line">        <span class="keyword">this</span>.foo();</div><div class="line">    &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="从对象到-Map"><a href="#从对象到-Map" class="headerlink" title="从对象到 Map"></a>从对象到 Map</h2><p>把语言结构 <em>object</em> 用作字符串到任意值的映射（一种数据结构）是 JavaScript 中一直以来的一种替代解决方案。实现这种影射最安全的方式就是创建一个 prototype 为 null 的对象，然后你还得确保没有键名会是 <code>__proto__</code> ，因为这个键名在很多 JavaScript 引擎中都会触发特殊的功能。</p>
<p>下面的 ES5 代码包含了函数 <code>countWords</code> ，该函数将对象 <code>dict</code> 用作一个 map ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dict = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countWords</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> escapedWord = escapeKey(word);</div><div class="line">    <span class="keyword">if</span> (escapedWord <span class="keyword">in</span> dict) &#123;</div><div class="line">        dict[escapedWord]++;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dict[escapedWord] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeKey</span>(<span class="params">key</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key.indexOf(<span class="string">'__proto__'</span>) === <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> key+<span class="string">'%'</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> key;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ES6 中，可以使用内置的数据结构 Map ，并且不需要转义键名。不过有一个缺点，对 map 中的值进行自增操作变得更不方便了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countWords</span>(<span class="params">word</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> count = map.get(word) || <span class="number">0</span>;</div><div class="line">    map.set(word, count + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>map 的另一个优点是可以用任何值作为键，而不仅仅是字符串。</p>
<h2 id="从-CommonJS-模块到-ES6-模块"><a href="#从-CommonJS-模块到-ES6-模块" class="headerlink" title="从 CommonJS 模块到 ES6 模块"></a>从 CommonJS 模块到 ES6 模块</h2><p>直到 ES5 ，基于 AMD 语法或者 CommonJS 语法的模块系统才几乎替代了手写的解决方案（比如<a href="http://christianheilmann.com/2007/08/22/again-with-the-module-pattern-reveal-something-to-the-world/" target="_blank" rel="external">暴露的模块方式</a>）。</p>
<p>ES6 内置支持模块。但是，目前还没有 JavaScript 引擎原生支持。但是像 browserfy 、 webpack 或者 jspm 这些工具让你能够使用 ES6 语法来创建模块，从而使你写的代码不会过时。</p>
<h3 id="导出多个值"><a href="#导出多个值" class="headerlink" title="导出多个值"></a>导出多个值</h3><p>在 CommonJS 里，像下面这样导出多个实体：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">var</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">    <span class="attr">sqrt</span>: sqrt,</div><div class="line">    <span class="attr">square</span>: square,</div><div class="line">    <span class="attr">diag</span>: diag,</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//------ main1.js ------</span></div><div class="line"><span class="keyword">var</span> square = <span class="built_in">require</span>(<span class="string">'lib'</span>).square;</div><div class="line"><span class="keyword">var</span> diag = <span class="built_in">require</span>(<span class="string">'lib'</span>).diag;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>相应地，你可以引入整个模块为一个对象，然后通过这个对象访问 <code>square</code> 和 <code>diag</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ main2.js ------</span></div><div class="line"><span class="keyword">var</span> lib = <span class="built_in">require</span>(<span class="string">'lib'</span>);</div><div class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(lib.diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>在 ES6 中，多个导出值被称为<em>命名导出</em>，像这样处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ lib.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x * x;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//------ main1.js ------</span></div><div class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'lib'</span>;</div><div class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>引入模块为对象的语法就像下面这样（行 A ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ main2.js ------</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lib <span class="keyword">from</span> <span class="string">'lib'</span>; <span class="comment">// (A)</span></div><div class="line"><span class="built_in">console</span>.log(lib.square(<span class="number">11</span>)); <span class="comment">// 121</span></div><div class="line"><span class="built_in">console</span>.log(lib.diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<h3 id="导出一个值"><a href="#导出一个值" class="headerlink" title="导出一个值"></a>导出一个值</h3><p>Node.js 使用了 CommonJS 的模块方案，允许通过 <code>module.exports</code> 在模块中导出一个值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ myFunc.js ------</span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ··· &#125;;</div><div class="line"></div><div class="line"><span class="comment">//------ main1.js ------</span></div><div class="line"><span class="keyword">var</span> myFunc = <span class="built_in">require</span>(<span class="string">'myFunc'</span>);</div><div class="line">myFunc();</div></pre></td></tr></table></figure>
<p>在 ES6 中， <code>export default</code> 完成同样的功能：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//------ myFunc.js ------</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; ··· &#125; <span class="comment">// no semicolon!</span></div><div class="line"></div><div class="line"><span class="comment">//------ main1.js ------</span></div><div class="line"><span class="keyword">import</span> myFunc <span class="keyword">from</span> <span class="string">'myFunc'</span>;</div><div class="line">myFunc();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;讲解了如何使用交互式的方式体验 ES6 。&lt;/li&gt;
&lt;li&gt;列举了容易被人接受的 ES6 特性，附带这些特性在 ES5 中的实现方式。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
      <category term="ECMAScript 6" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"/>
    
  </entry>
  
  <entry>
    <title>一个 JavaScript</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/%E4%B8%80%E4%B8%AA%20JavaScript.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/一个 JavaScript.html</id>
    <published>2015-10-04T16:00:00.000Z</published>
    <updated>2016-06-15T10:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。</p>
<p>那么，什么是“版本化”？什么又是“一个 JavaScript”呢？<br><a id="more"></a></p>
<h2 id="版本化"><a href="#版本化" class="headerlink" title="版本化"></a>版本化</h2><p>一般地，版本化就是说一门语言分成了不同的版本，新版本可以清理老版本中不好的特性，或者改变某些特性的运作方式。这就会导致新的代码无法在老引擎中运行，老的代码也不能在新引擎中运行。很可能某些代码就只能在特定版本的引擎中正常运行，然后针对不同版本的引擎，就要写不同的代码。</p>
<p>如果代码库升级到新的语言版本，就有两种处理方式。</p>
<p>第一种，彻底升级代码库中所有的代码。但是如果代码库的代码量很大的话，就很坑爹了。</p>
<p>第二种，让代码库包含多个语言版本的代码，根据指定的语言版本使用不同的执行引擎。对于 ES6 ，就可以使用媒体类型来标记 ES6 代码，比如在 HTTP 响应头中设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Content-Type: application/ecmascript;version=6</div></pre></td></tr></table></figure>
<p>也可以利用 <code>&lt;script&gt;</code> 标签的 <code>type</code> 属性来标记：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/ecmascript;version=6"</span>&gt;</span><span class="undefined"></span></div><div class="line">    ···</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>也可以在代码内部标记版本（类似于 <code>&#39;use strict&#39;</code> ，放在 JavaScript 文件第一行）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">use version <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p>这两种类型的标记方式都有问题：外部版本标记法很脆弱，容易丢失；内部版本标记法又会使代码显得杂乱。</p>
<p>一个更根本的问题是，针对不同的语言版本，要维护不同的执行引擎。这就产生了几个问题：</p>
<ul>
<li>引擎变得很臃肿，因为要实现所有版本的语法。对于语言分析工具也带来了同样的问题（比如类型检测， JSLint ）。</li>
<li>开发者需要记住版本之间的不同点。</li>
<li>代码变得更加难以重构，因为在移动代码的时候需要考虑语言版本的问题。</li>
</ul>
<p>因此，应该避免版本化，尤其是 JavaScript 和 web 。</p>
<h2 id="一个-JavaScript"><a href="#一个-JavaScript" class="headerlink" title="一个 JavaScript"></a>一个 JavaScript</h2><p>既然版本化有这么多弊端，对于 JavaScript 和 web 来说都不适用，那么如何避免版本化呢？</p>
<p>采用向后兼容的方式。这就是说我们必须放弃一些关于清理 JavaScript 语言的野心：不能引入破坏性的改变。向后兼容就是不移除已有特性，也不改变已有特性。该规则的口号就是：“不要破坏 web 代码”。</p>
<p>我们可以增加新的特性，使已有的特性更加强大。</p>
<p>这样一来，新的语言和引擎就不需要版本号了，因为仍然需要能够运行老的代码。 David Herman 称这种避免版本化的方式为“<a href="http://exploringjs.com/es6/ch_one-javascript.html#one-js_1" target="_blank" rel="external">一个 JavaScript </a>”，它避免了 JavaScript 被拆分成不同的版本或者模式。甚至，“一个 JavaScript ”纠正了之前由于严格模式引入的 JavaScript 分支。</p>
<p>“一个 Javascript ”并不是说就要完全放弃对语言的清理。相对于去掉已有的特性，可以引入新的干净的特性。 <code>let</code> 就是这样干的，它用于声明块级变量，是 <code>var</code> 的改进版。但是它并没有替换掉 <code>var</code> ，只是作为更好的方案与 <code>var</code> 并存。</p>
<p>将来某个时候，可能会清除掉不再有人使用的特性。实际上，一些 ES6 特性是通过调查 web 上的代码来设计的，比如下面两个：</p>
<ul>
<li><code>let</code> 声明很难引入到非严格模式中，因为在非严格模式下 let 并不是保留字。在 ES5 中，有且仅有一种形式的 let 变量是合法的：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span>[x] = arr;</div></pre></td></tr></table></figure>
<p>调查发现， web 上没人会在非严格模式下这样使用 <code>let</code> 变量，这就使得 TC39 能够将 <code>let</code> 引入非严格模式中。</p>
<h2 id="严格模式和-ES6"><a href="#严格模式和-ES6" class="headerlink" title="严格模式和 ES6"></a>严格模式和 ES6</h2><p>ECMAScript 5 引入严格模式来对语言进行清理。在文件或者函数的第一行放入下面的内容就可以打开严格模式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div></pre></td></tr></table></figure>
<p>严格模式带来了三种具有破坏性的改变：</p>
<ul>
<li>语法改变：一些之前合法的语法在严格模式下面是不允许的。例如：<ul>
<li>禁止 with 语句。它允许开发者添加任何对象到作用域链，这会减缓程序的执行速度，并且很难指出某个变量指向哪里。</li>
<li>删除一个<code>独立的标识符</code>（是一个变量，而不是一个属性）是不允许的。</li>
<li>函数只能在作用域的顶层声明。</li>
<li>更多的保留字： implements interface let package private protected public static yield 。</li>
</ul>
</li>
<li>更多类型的错误。例如：<ul>
<li>给一个未声明的变量赋值会抛出 <code>ReferenceError</code> 。而在非严格模式下，这样做就会创建一个全局变量。</li>
<li>修改只读的属性（比如字符串的长度属性）会抛出 <code>TypeError</code> 。而在非严格模式下，不会产生任何效果。</li>
</ul>
</li>
<li>不同的语义：在严格模式下，一些结构体会表现得不一样。例如：<ul>
<li><code>arguments</code> 不再随着当前参数值的改变而改变。</li>
<li>在非方法的函数中 <code>this</code> 为 <code>undefined</code> 。在非严格模式下，它指向全局对象（ window ）。如果调用一个构造器的时候没有使用 new ，就会创建一些全局变量。</li>
</ul>
</li>
</ul>
<p>从严格模式的这些破坏性改变中可以看出，版本化是很棘手的：即便能够制定出一个干净版本的 JavaScript ，也很难被大家接受。主要原因在于会破坏很多现有的代码，会减缓执行速度，并且引入到文件很繁琐（更不用说交互式的命令行）。</p>
<h2 id="支持松散（非严格）模式"><a href="#支持松散（非严格）模式" class="headerlink" title="支持松散（非严格）模式"></a>支持松散（非严格）模式</h2><p><code>一个 JavaScript</code> 意味着我们不能放弃松散模式：此模式将会继续存在（例如在 HTML 属性中）。因此，我们不能基于严格模式来构建 ECMAScript 6 ，必须同时在严格模式和非严格模式（又称为松散模式）中都增加相同的特性。否则，严格模式就会成为语言的一个不同版本，回到了版本化的方式。</p>
<p>但是很不幸，有两个特性很难引入松散模式： <code>let</code> 声明和块级函数声明。让我们看看为什么很难引入和如何引入。</p>
<h2 id="松散模式中的-let-声明"><a href="#松散模式中的-let-声明" class="headerlink" title="松散模式中的 let 声明"></a>松散模式中的 <code>let</code> 声明</h2><p><code>let</code> 使你能够声明块级变量。这很难被引入到松散模式，因为 <code>let</code> 仅在严格模式下是保留字。也就是说，下面两条语句在 ES5 的松散模式下是合法的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="keyword">let</span> = [];</div><div class="line"><span class="keyword">let</span>[x] = <span class="string">'abc'</span>;</div></pre></td></tr></table></figure>
<p>在 ECMASCript 6 的严格模式下，第一行就会抛出异常。因为使用了 <code>let</code> 作为变量名。然后第二行会被解析为一个 <code>let</code> 变量声明（使用解构）。</p>
<p>在 ECMAScript 6 的松散模式下，第一行不会抛出异常，但是第二行依然被解析为一个 <code>let</code> 声明。这种使用 <code>let</code> 的方式在 web 上是极少见的，因此 ES6 可以直接这样来解析。 ES5 松散模式下的其他 <code>let</code> 声明的书写方式不会被误解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo = <span class="number">123</span>;</div><div class="line"><span class="keyword">let</span> &#123;x,y&#125; = computeCoordinates();</div></pre></td></tr></table></figure>
<h2 id="松散模式下的块级函数声明"><a href="#松散模式下的块级函数声明" class="headerlink" title="松散模式下的块级函数声明"></a>松散模式下的块级函数声明</h2><p>ECMAScript 5 严格模式中，是禁止在块中声明函数的；在松散模式下，却可以这么做，但是没说这样做会发生什么。因此，很多 JavaScript 实现都支持块级函数声明，但是处理方式是不一样的。</p>
<p>ECMAScript 6 想要块中的函数声明本地化（即该函数的作用域就在该块中）。作为 ES5 严格模式的升级，这是没问题的，但是会破坏一些松散模式的代码。因此， ES6 为浏览器提供了“<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="external"> web 遗留的兼容语义</a>”，允许块中的函数声明在函数作用域范围内存在。</p>
<h2 id="其它关键字"><a href="#其它关键字" class="headerlink" title="其它关键字"></a>其它关键字</h2><p>标识符 <code>yield</code> 和 <code>static</code> 仅在 ES5 的严格模式下是保留字。 ECMAScript 6 使用上下文相关的语法规则来使它们在松散模式下起作用：</p>
<ul>
<li>在松散模式下， <code>yield</code> 仅在生成器函数中是保留字。</li>
<li><code>static</code> 现在仅用于类字面量中，类字面中默认就是严格模式的（见下文）。</li>
</ul>
<h2 id="隐式的严格模式"><a href="#隐式的严格模式" class="headerlink" title="隐式的严格模式"></a>隐式的严格模式</h2><p>在 ECMAScript 6 中，模块体和类体默认就是严格模式的–没必要使用 <code>use strict</code> 标记。考虑到将来所有的代码都会位于模块中， ECMAScript 6 有效地将整个语言升级到了严格模式。</p>
<p>其它语法结构（比如箭头函数和生成器函数）本来也应该隐式地为严格模式，但是考虑到通常情况下这些结构都很小，在非严格模式下使用它们就会造成代码中两种模式的碎片化切换。类，尤其是模块一般是足够大的，这样一来就可以忽略两种模式的碎片化切换问题了。</p>
<h2 id="无法修复的东西"><a href="#无法修复的东西" class="headerlink" title="无法修复的东西"></a>无法修复的东西</h2><p><code>一个 JavaScript</code>的缺陷就是无法修复已有的怪异行为，尤其是下面这两个。</p>
<p>第一个， <code>typeof null</code> 应该返回字符串 <code>null</code> 而不是 <code>object</code> ，修正这个就会破坏已有的代码。而另一方面，给新类型的操作数定义新的操作结果是没问题的， ECMAScript 6 的 Symbol 就是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; typeof Symbol.iterator</div><div class="line">&apos;symbol&apos;</div></pre></td></tr></table></figure>
<p>第二个，全局对象（浏览器中的 <code>window</code> 对象）不应该在变量作用域链，现在修正这个也太晚了。但是至少，在模块中不会直接处于全局作用域下，并且 <code>let</code> 永远不会创建全局对象属性，甚至在全局作用域下使用也不会。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>一个 JavaScript</code>意思就是使 ECMAScript 6 完全地向后兼容，很高兴这获得了成功。尤其是模块隐式就是严格模式的（这样一来我们大部分的代码都会处于严格模式下）。</p>
<p>在短期内，对于制定 ES6 规范和引擎实现来说，给严格模式和松散模式添加 ES6 的语法结构会耗费更多的精力。从长远来看，规范和引擎将会受益于语言不分叉（更少的膨胀等等）。开发人员会立即从一个 JavaScript 中获得好处，因为开始使用 ECMAScript 6 变得更加容易。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6 使用了“一个 JavaScript ”的方式来避免版本化的问题。&lt;/p&gt;
&lt;p&gt;那么，什么是“版本化”？什么又是“一个 JavaScript”呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/JavaScript/"/>
    
      <category term="ECMAScript 6" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/ECMAScript-6/"/>
    
  </entry>
  
  <entry>
    <title>CSS 语法速查</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS%20%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS 语法速查.html</id>
    <published>2015-09-03T11:06:00.000Z</published>
    <updated>2016-06-15T10:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h3 id="background"><a href="#background" class="headerlink" title="background"></a><a href="http://www.w3.org/TR/css3-background/" target="_blank" rel="external">background</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ &lt;bg-layer&gt; , ]* &lt;final-bg-layer&gt;</div><div class="line"></div><div class="line">    &lt;bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt;</div><div class="line">    &lt;final-bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt; || &lt;box&gt; || &lt;&apos;background-color&apos;&gt;</div><div class="line"></div><div class="line">        &lt;bg-image&gt; = &lt;image&gt; | none</div></pre></td></tr></table></figure>
<p><a href="http://www.w3.org/TR/css3-background/#ltimagegt" target="_blank" rel="external">&lt;image&gt;</a><br><a href="http://www.w3.org/TR/css3-background/#ltpositiongt" target="_blank" rel="external">&lt;position&gt;</a><br><a href="http://www.w3.org/TR/css3-background/#ltbg-sizegt" target="_blank" rel="external">&lt;bg-size&gt;</a><br><a href="http://www.w3.org/TR/css3-background/#ltrepeat-stylegt" target="_blank" rel="external">&lt;repeat-style&gt;</a><br><a href="http://www.w3.org/TR/css3-background/#ltattachmentgt" target="_blank" rel="external">&lt;attachment&gt;</a><br><a href="http://www.w3.org/TR/css3-background/#ltboxgt" target="_blank" rel="external">&lt;box&gt;</a></p>
<h3 id="radial-gradient"><a href="#radial-gradient" class="headerlink" title="radial-gradient()"></a><a href="http://www.w3.org/TR/2012/CR-css3-images-20120417/#radial-gradients" target="_blank" rel="external">radial-gradient()</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;radial-gradient&gt; = radial-gradient(</div><div class="line">  [ [ &lt;shape&gt; || &lt;size&gt; ] [ at &lt;position&gt; ]? , |</div><div class="line">    at &lt;position&gt;,</div><div class="line">  ]?</div><div class="line">  &lt;color-stop&gt; [ , &lt;color-stop&gt; ]+</div><div class="line">)</div><div class="line"></div><div class="line">    &lt;shape&gt; = circle || ellipse</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;background&quot;&gt;&lt;a href=&quot;#background&quot; class=&quot;headerlink&quot; title=&quot;background&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/css3-bac
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 空心字</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS%20%E7%A9%BA%E5%BF%83%E5%AD%97.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS 空心字.html</id>
    <published>2015-09-01T16:00:00.000Z</published>
    <updated>2016-06-15T10:45:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>空心字。<br><a id="more"></a></p>
<h3 id="闪烁的空心字"><a href="#闪烁的空心字" class="headerlink" title="闪烁的空心字"></a>闪烁的空心字</h3><iframe src="../demos/空心字1.html" width="100%" height="96" frameborder="0" allowfullscreen></iframe>
<h3 id="带背景渐变的空心字"><a href="#带背景渐变的空心字" class="headerlink" title="带背景渐变的空心字"></a>带背景渐变的空心字</h3><iframe src="../demos/空心字2.html" width="100%" height="91" frameborder="0" allowfullscreen></iframe>
<p>text-shadow 是绘制在 background 之上的，如果想要文字同时能应用 text-shadow 和 background-image ，那么就必须使用一定的技巧了，不然就会造成 text-shadow 的颜色遮住 background 的颜色。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;空心字。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS 变形</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS%20%E5%8F%98%E5%BD%A2.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS 变形.html</id>
    <published>2015-08-31T16:00:00.000Z</published>
    <updated>2016-06-15T10:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2D"><a href="#2D" class="headerlink" title="2D"></a>2D</h2><p>2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。<br><a id="more"></a></p>
<h3 id="skew-函数"><a href="#skew-函数" class="headerlink" title="skew() 函数"></a>skew() 函数</h3><p>示例：</p>
<iframe src="../demos/css%20skew.html" width="100%" height="320" frameborder="0" allowfullscreen></iframe>
<p>下图描述了<code>skew(30deg, 10deg)</code>的工作原理：</p>
<p><img src="../images/10.jpg" alt=""></p>
<blockquote>
<p><strong>注：</strong>上图来自 <a href="http://dtop.powereasy.net/Item/3715.aspx" target="_blank" rel="external">http://dtop.powereasy.net/Item/3715.aspx</a> 。</p>
</blockquote>
<h3 id="transform-origin"><a href="#transform-origin" class="headerlink" title="transform-origin"></a>transform-origin</h3><p>transform-origin 用来指定元素变形的中心点位置，默认就是元素的中心点。</p>
<p>但是，对于位移 translate() 函数来说，无论 transform-origin 如何改变，都是以元素中心点为基准进行位移，例如：</p>
<iframe src="../demos/transform-origin.html" width="100%" height="440" frameborder="0" allowfullscreen></iframe>
<p><code>示例1</code>和<code>示例2</code>中的虚线框是元素的原始位置，实线框是位移之后的位置。<code>示例1</code>的 transform-origin 是<code>50% 50%</code>，而<code>示例2</code>是<code>100% 100%</code>，但是从最终偏移效果来看，两者的结果是一样的，所以 tranform-origin 对 translate() 函数并没有影响。</p>
<h2 id="3D"><a href="#3D" class="headerlink" title="3D"></a>3D</h2><p>3D 常用变形函数： translate3d() 、 translate() 、 scale3d() 、 scaleZ() 、 rotate3d() 、 rotateX() 、 rotateY() 、 rotateZ() 、 perspective() 、 matrix3d() 。</p>
<h3 id="transform-style"><a href="#transform-style" class="headerlink" title="transform-style"></a>transform-style</h3><p>transform-style 的取值为 <code>flat</code> 或者 <code>preserve-3d</code> 。下面的例子展示了两者的差别：</p>
<iframe src="../demos/transform-style.html" width="100%" height="416" frameborder="0" allowfullscreen></iframe>
<p>从示例中可以看出， <code>preserve-3d</code> 会让子元素在父元素变形的基础上继续变形，而 <code>flat</code> 则会消除父元素变形对子元素变形带来的影响。</p>
<p><strong>理解：</strong></p>
<p>对于第一种 <code>div.container1</code> 元素的 transform-style 为 <code>flat</code> 的情形，表明其所有子元素在 2D 空间中呈现，于是相对于 2D 平面（就可以理解为显示器的那个平面）做变形；对于第二种 <code>div.container1</code> 元素的 transform-style 为 <code>preserve-3d</code> 的情形，表明其所有子元素在 3D 空间中呈现，于是相对于当前 <code>div.container1</code> 为基准的平面做变形。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2D&quot;&gt;&lt;a href=&quot;#2D&quot; class=&quot;headerlink&quot; title=&quot;2D&quot;&gt;&lt;/a&gt;2D&lt;/h2&gt;&lt;p&gt;2D 常用的变形函数： tranlate() 、 scale() 、 rotate() 、 skew() 、 matrix() 。&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS border-radius</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS%20border-radius.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS border-radius.html</id>
    <published>2015-08-26T16:00:00.000Z</published>
    <updated>2016-06-15T10:44:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>border-radius</code> 的取值：<br><a id="more"></a></p>
<blockquote>
<p>[ &lt;length&gt; | &lt;percentage&gt; ]{1,4} [ / [ &lt;length&gt; | &lt;percentage&gt; ]{1,4} ]?</p>
</blockquote>
<iframe src="../demos/border-radius.html" width="100%" height="116" frameborder="0" allowfullscreen></iframe>
<p>上述示例的 CSS 代码为：</p>
<p>border-radius 是可以通过<code>/</code>的形式来对某一个角设置一个椭圆弧的。</p>
<p>比如示例中的 <code>20px/5px</code> 的含义是：对于左上角的圆弧，圆心到上边框的距离是5px，到左边框的距离是20px；对于右上角的圆弧，圆心到上边框的距离是5px，到右边框的距离是20px；对于右下角的圆弧，圆心到下边框的距离是5px，到右边框的距离是20px；对于左下角的圆弧，圆心到下边框的距离是5px，到左边框的距离是20px。</p>
<p>如果 border-radius 的半径小于或等于元素的边框厚度时，边框内角就会变成直角效果。</p>
<p>对 img 元素运用 border-radius ， webkit 内核不能使图片边角出现圆角的效果，可以使用背景图片的方式来修正这个问题。</p>
<p>当表格样式属性 border-collapse 是 collapse 时，对表格使用 border-radius 圆角效果，表格将不会展现出圆角效果，只有 border-collapse 为 separate 的时候，圆角才能正常展示。</p>
<p>border-radius 可以做的效果：圆形、半圆、扇形、椭圆。</p>
<iframe src="../demos/half%20ellipse.html" width="100%" height="116" frameborder="0" allowfullscreen></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;border-radius&lt;/code&gt; 的取值：&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS border-image</title>
    <link href="http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS%20border-image.html"/>
    <id>http://yibuyisheng.github.io/blogs/site/index.html/blogs/CSS border-image.html</id>
    <published>2015-08-26T16:00:00.000Z</published>
    <updated>2016-06-15T10:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<iframe src="../demos/border-image.html" width="100%" height="336" frameborder="0" allowfullscreen></iframe>
<p>上面示例的 css 代码为：<br><a id="more"></a></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.demo1</span> &#123;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">200px</span>;</div><div class="line"></div><div class="line">    <span class="attribute">border-width</span>: <span class="number">60px</span> <span class="number">70px</span>;</div><div class="line">    <span class="attribute">border-image</span>: <span class="built_in">url</span>(../images/8.jpg) <span class="number">60</span> <span class="number">70</span> round stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CSS 中的 border-image 可以给边框设置图片背景，其参数主要分为三部分：</p>
<ul>
<li>1、图片来源。即示例中的 <code>url(../images/8.jpg)</code> ；</li>
<li>2、图片裁剪尺寸。即示例中的 <code>60 70</code>。裁剪尺寸遵循 <code>top-right-bottom-left</code> 规则，其数值可以是百分数，也可以是像素值。如果是像素值，则不能带单位，直接写数值就好了，示例中<code>60 70</code>的含义为：对图片实施裁剪，图片上部和下部分别裁掉60px，左部和右部分别裁掉70px，于是图片就形成9块，四个边角块是无法运用round（平铺）等效果的，中间那一块是没用的。如果为百分数，则是根据图片的尺寸来计算出相应的像素值的；</li>
<li>3、图片可运用效果区域的展示效果。取值为 [round|repeat|stretch] 。正如2中所述，图片会被裁剪成9块，而这个展示效果只能运用于上、右、下、左的中间那一块。</li>
</ul>
<p><code>-webkit-border-image</code> 是有 bug 的，它会用裁剪后的9块图片的中间那一张覆盖掉背景。如下所示：</p>
<iframe src="../demos/-webkit-border-image.html" width="100%" height="336" frameborder="0" allowfullscreen></iframe>
]]></content>
    
    <summary type="html">
    
      &lt;iframe src=&quot;../demos/border-image.html&quot; width=&quot;100%&quot; height=&quot;336&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;p&gt;上面示例的 css 代码为：&lt;br&gt;
    
    </summary>
    
    
      <category term="CSS" scheme="http://yibuyisheng.github.io/blogs/site/index.html/tags/CSS/"/>
    
  </entry>
  
</feed>
